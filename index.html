<!DOCTYPE html>

<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>Electrical Line Survey V3.8 (Dynamic)</title>

<link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />

<style>
* {
margin: 0;
padding: 0;
box-sizing: border-box;
}

body {
font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
background: linear-gradient(135deg, #e0f2fe 0%, #ddd6fe 100%);
min-height: 100vh;
padding: 16px;
padding-bottom: 60px;
}

.container {
max-width: 1200px;
margin: 0 auto;
}

.card {
background: white;
border-radius: 16px;
box-shadow: 0 10px 30px rgba(0,0,0,0.1);
padding: 24px;
margin-bottom: 24px;
}

.header {
display: flex;
justify-content: space-between;
align-items: center;
margin-bottom: 20px;
flex-wrap: wrap;
gap: 16px;
}

.header-left {
display: flex;
align-items: center;
gap: 16px;
}

.icon-box {
background: #3b82f6;
padding: 12px;
border-radius: 12px;
color: white;
font-size: 28px;
}

.title-section h1 {
font-size: 24px;
color: #1f2937;
margin-bottom: 4px;
}

.title-section p {
font-size: 14px;
color: #6b7280;
}

.distance-display {
text-align: right;
}

.distance-value {
font-size: 32px;
font-weight: bold;
color: #3b82f6;
}

.distance-label {
font-size: 14px;
color: #6b7280;
}

.stats-grid {
display: grid;
grid-template-columns: repeat(3, 1fr);
gap: 16px;
margin-top: 20px;
}

.stat-card {
padding: 16px;
border-radius: 12px;
}

.stat-card.blue { background: #eff6ff; }
.stat-card.green { background: #f0fdf4; }
.stat-card.purple { background: #faf5ff; }

.stat-label {
font-size: 14px;
color: #6b7280;
margin-bottom: 4px;
}

.stat-value {
font-size: 24px;
font-weight: bold;
}

.stat-value.blue { color: #3b82f6; }
.stat-value.green { color: #10b981; }
.stat-value.purple { color: #a855f7; }

.btn {
padding: 12px 24px;
border: none;
border-radius: 12px;
font-size: 16px;
font-weight: 600;
cursor: pointer;
display: flex;
align-items: center;
justify-content: center;
gap: 8px;
transition: all 0.2s;
width: 100%;
}

.btn:disabled {
background: #d1d5db !important;
color: #9ca3af !important;
cursor: not-allowed;
}

.btn-green {
background: #10b981;
color: white;
}

.btn-green:hover:not(:disabled) {
background: #059669;
}

.btn-red {
background: #ef4444;
color: white;
}

.btn-red:hover:not(:disabled) {
background: #dc2626;
}

.btn-blue {
background: #3b82f6;
color: white;
}

.btn-blue:hover:not(:disabled) {
background: #2563eb;
}

.btn-purple {
background: #a855f7;
color: white;
}

.btn-purple:hover:not(:disabled) {
background: #9333ea;
}

/* --- New / Modified Styles for Dynamic Selection --- */

.selection-group {
margin-bottom: 20px;
padding: 15px;
border: 1px solid #e5e7eb;
border-radius: 12px;
background-color: #f9fafb;
}

.selection-group-title {
display: block;
font-weight: 700;
margin-bottom: 12px;
color: #1f2937;
font-size: 16px;
}

.radio-grid {
display: grid;
grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
gap: 10px;
}

.radio-group label {
display: flex;
align-items: center;
padding: 10px;
border: 2px solid #d1d5db;
border-radius: 8px;
font-size: 14px;
cursor: pointer;
transition: all 0.2s;
background-color: white;
}

.radio-group input[type="radio"] {
margin-right: 8px;
accent-color: #3b82f6;
}

.radio-group input[type="radio"]:checked + span {
font-weight: 600;
color: #3b82f6;
}

.radio-group input[type="radio"]:checked ~ label {
border-color: #3b82f6;
background-color: #eff6ff;
}

select {
width: 100%;
padding: 12px;
border: 1px solid #d1d5db;
border-radius: 8px;
font-size: 16px;
background-color: white;
appearance: none;
-webkit-appearance: none;
background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='%236B7280'%3E%3Cpath d='M7 10l5 5 5-5z'/%3E%3C/svg%3E");
background-repeat: no-repeat;
background-position: right 12px center;
background-size: 16px;
}

.marker-types {
display: grid;
grid-template-columns: repeat(4, 1fr);
gap: 12px;
margin-top: 16px;
}

.marker-btn {
padding: 16px;
border: none;
border-radius: 12px;
background: #f3f4f6;
cursor: pointer;
transition: all 0.2s;
font-weight: 600;
}

.marker-btn:hover {
background: #e5e7eb;
}

.marker-btn.active {
background: #3b82f6;
color: white;
}

.marker-icon {
font-size: 32px;
margin-bottom: 8px;
}

.marker-label {
font-size: 14px;
}

/* --- End of New / Modified Styles --- */


.button-grid {
display: grid;
grid-template-columns: repeat(2, 1fr);
gap: 12px;
}

canvas {
width: 100%;
border: 2px solid #e5e7eb;
border-radius: 12px;
}

.markers-list {
max-height: 300px;
overflow-y: auto;
}

.marker-item {
display: flex;
align-items: center;
justify-content: space-between;
background: #f9fafb;
padding: 12px;
border-radius: 12px;
margin-bottom: 8px;
}

.marker-info {
display: flex;
align-items: center;
gap: 12px;
}

.marker-item-icon {
font-size: 24px;
}

.marker-details h4 {
font-size: 16px;
color: #1f2937;
margin-bottom: 4px;
}

.marker-coords {
font-size: 12px;
color: #6b7280;
}

.span-length {
font-size: 12px;
font-weight: bold;
color: #3b82f6;
margin-left: 8px;
}

.delete-btn {
background: #fee2e2;
color: #ef4444;
border: none;
padding: 8px;
border-radius: 8px;
cursor: pointer;
transition: all 0.2s;
}

.delete-btn:hover {
background: #fecaca;
}

h2 {
font-size: 18px;
color: #1f2937;
margin-bottom: 16px;
}

input[type="file"] {
display: none;
}

label.btn {
cursor: pointer;
}

.text-input-group {
margin-bottom: 20px;
}

.text-input-group label {
display: block; 
font-weight: 600; 
margin-bottom: 8px; 
color: #374151;
}

.text-input-group input {
width: 100%; 
padding: 12px; 
border: 1px solid #d1d5db; 
border-radius: 8px; 
font-size: 16px;
}

.footer-info {
text-align: center;
padding: 20px 0;
font-size: 12px;
color: #6b7280;
margin-top: 24px;
border-top: 1px solid #e5e7eb;
}
.footer-info p {
margin: 4px 0;
}

#leafletMap {
height: 500px; 
width: 100%;
border: 2px solid #e5e7eb;
border-radius: 12px;
}

@media (max-width: 768px) {
.stats-grid {
grid-template-columns: 1fr;
}

.marker-types {
grid-template-columns: repeat(2, 1fr);
}

.radio-grid {
grid-template-columns: 1fr;
}

.button-grid {
grid-template-columns: 1fr;
}

.header {
flex-direction: column;
text-align: center;
}

.distance-display {
text-align: center;
}
}
</style>

</head>
<body>
<div class="container">
<div class="card">
<div style="text-align: right; margin-bottom: 10px;">
<a href="https://drive.google.com/file/d/1AtU_U-QRIqjK1npsIydHofihzbMXOD5J/view?usp=drivesdk" target="_blank" style="color: #3b82f6; text-decoration: none; font-weight: 600; font-size: 14px;">
üìñ User Manual
</a>
</div>
<div class="header">
<div class="header-left">
<div class="icon-box">‚ö°</div>
<div class="title-section">
<h1>Electrical Line Survey V3.8 (Dynamic)</h1>
<p>GPS-based line tracking & mapping</p>
</div>
</div>
<div class="distance-display">
<div class="distance-value" id="totalDistance">0.0m</div>
<div class="distance-label">Total Distance (Straight Line)</div>
</div>
</div>

<div class="stats-grid">
<div class="stat-card blue">
<div class="stat-label">Points</div>
<div class="stat-value blue" id="pointsCount">0</div>
</div>
<div class="stat-card green">
<div class="stat-label">Markers</div>
<div class="stat-value green" id="markersCount">0</div>
</div>
<div class="stat-card purple">
<div class="stat-label">Accuracy</div>
<div class="stat-value purple" id="accuracy">--</div>
</div>
</div>
</div>

<div class="card">
<h2>Controls</h2>

<div class="text-input-group">
<label for="siteNameInput">Site Name</label>
<input type="text" id="siteNameInput" value="New Survey Site" oninput="updateSiteName(this.value)">
</div>

<div class="selection-group" style="margin-top: 20px;">
<label class="selection-group-title">0. Select Survey Type</label>
<div class="radio-grid">
<div class="radio-group">
<label>
<input type="radio" name="surveyType" value="proposed" onchange="updateSurveyType(this.value)" checked>
<span>Proposed Line Survey</span>
</label>
</div>
<div class="radio-group">
<label>
<input type="radio" name="surveyType" value="existing" onchange="updateSurveyType(this.value)">
<span>Existing Line Survey</span>
</label>
</div>
</div>
</div>
<button class="btn btn-green" id="startBtn" onclick="startTracking()">
‚ñ∂ Start Tracking
</button>
<button class="btn btn-red" id="stopBtn" onclick="stopTracking()" style="display:none;">
‚èπ Stop Tracking
</button>
<div id="gpsStatus" style="margin-top: 10px; color: #f97316; font-weight: 600;"></div> 

<div style="margin-top: 20px;">

<div class="selection-group">
<label class="selection-group-title">1. Select Line Type</label>

<div class="radio-grid" id="lineTypeSelection">
<div class="radio-group">
<label>
<input type="radio" name="lineType" value="HT_33kV" data-main-type="HT" onchange="updateLineSubtype(this.value)">
<span>33 KV HT Line</span>
</label>
</div>
<div class="radio-group">
<label>
<input type="radio" name="lineType" value="HT_22kV" data-main-type="HT" onchange="updateLineSubtype(this.value)">
<span>22 kV HT Line</span>
</label>
</div>
<div class="radio-group">
<label>
<input type="radio" name="lineType" value="HT_11kV" data-main-type="HT" onchange="updateLineSubtype(this.value)" checked>
<span>11 KV HT Line</span>
</label>
</div>

<div class="radio-group">
<label>
<input type="radio" name="lineType" value="LT_3P" data-main-type="LT" onchange="updateLineSubtype(this.value)">
<span>3-phase LT Line</span>
</label>
</div>
<div class="radio-group">
<label>
<input type="radio" name="lineType" value="LT_2P" data-main-type="LT" onchange="updateLineSubtype(this.value)">
<span>2-phase LT Line</span>
</label>
</div>
<div class="radio-group">
<label>
<input type="radio" name="lineType" value="LT_1P" data-main-type="LT" onchange="updateLineSubtype(this.value)">
<span>1-phase LT Line</span>
</label>
</div>
</div>
</div>

<div class="selection-group">
<label class="selection-group-title" for="conductorTypeSelect">2. Select Conductor Type</label>
<select id="conductorTypeSelect" onchange="updateConductorType(this.value)">
</select>
</div>

<label style="display: block; font-weight: 600; margin-bottom: 12px; color: #374151;">3. Select Marker Type</label>
<div class="marker-types" id="markerTypeSelection">
</div>
</div>

<button class="btn btn-blue" id="addMarkerBtn" onclick="addMarker()" disabled style="margin-top: 16px;">
üìç Add <span id="markerTypeLabel">Pole</span> at Current Location
</button>

</div>

<div class="card">
<h2>Survey Map (Schematic View)</h2>
<canvas id="mapCanvas" width="800" height="500"></canvas>
</div>

<div class="card">
<h2>Interactive Map View (Leaflet/OSM)</h2>
<div id="leafletMap"></div>
</div>
<div class="card">
<h2>Actions</h2>
<div class="button-grid">
<button class="btn btn-green" onclick="saveToJSON()">
üíæ Save JSON
</button>
<label class="btn btn-blue">
üì§ Load JSON
<input type="file" accept=".json" onchange="loadFromJSON(event)">
</label>
<button class="btn btn-purple" onclick="exportToPNG()">
üìÑ Export Main PNG (A3)
</button>
<button class="btn btn-purple" onclick="exportToDetailedPNG()">
üìú Export Details PNG (A3)
</button>
<button class="btn btn-blue" onclick="exportToCSV()">
üìä Export CSV
</button>
<button class="btn btn-red" onclick="clearAll()">
üóëÔ∏è Clear All
</button>
</div>
</div>

<div class="card" id="markersListCard" style="display:none;">
<h2>Marked Locations</h2>
<div class="markers-list" id="markersList"></div>
</div>

</div> 
<div class="footer-info">
<p>Electrical Line Survey App | Version 3.8 (Dynamic)</p>
<p>Developed for Professional Field Use | For Support: +91-70187-56182/ErAjay.HPSEB@gmail.com</p>
<p>¬© 2025‚Äì26 ErAjay Kumar . All rights reserved.</p>
</div>

<script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>

<script>
// State
let isTracking = false;
let isManualPosition = false;
let linePoints = [];
let markers = [];
let totalDistance = 0;
let currentPosition = null;
let siteName = document.getElementById('siteNameInput').value;
let selectedMarkerType = 'single_pole'; // Default to a pole marker
let accuracy = null;
let watchId = null;
let startFromMarkerIndex = null;
let startFromMarkerPosition = null;

// New Dynamic State
let selectedLineMainType = 'HT'; // HT or LT
let selectedLineSubtype = 'HT_11kV'; // HT_33kV, LT_3P, etc.
let selectedConductorType = 'ACSR_6_1_472'; // Key from conductorConfig
let selectedSurveyType = 'proposed'; // NEW STATE: 'proposed' or 'existing'

// Leaflet Map State
let leafletMapInstance = null;
let leafletMarkers = [];
let leafletPolylines = [];
let mapTiles = null;
let satelliteTiles = null;

// GPS FILTERS
const MIN_MOVEMENT_DISTANCE = 2.0;
const MAX_ACCURACY_ERROR = 10.0;
const ACCURACY_THRESHOLD = 10.0;
const INITIAL_FIX_TIMEOUT = 30000;
let initialFixAttempt = false;
let initialFixTimeoutId = null;

// --- NEW CONFIGURATION DATA ---
const lineConfig = {
'HT_33kV': { label: '33 kV HT Line', color: '#dc2626', mainType: 'HT' },
'HT_22kV': { label: '22 kV HT Line', color: '#f97316', mainType: 'HT' },
'HT_11kV': { label: '11 kV HT Line', color: '#facc15', mainType: 'HT' },
'LT_3P': { label: '3-phase LT Line', color: '#2563eb', mainType: 'LT' },
'LT_2P': { label: '2-phase LT Line', color: '#059669', mainType: 'LT' },
'LT_1P': { label: '1-phase LT Line', color: '#a855f7', mainType: 'LT' }
};

const conductorConfig = {
'ACSR_6_1_259': { label: 'Bare ACSR 6/1/2.59', group: 'Bare', color: '#6b7280' },
'ACSR_6_1_335': { label: 'Bare ACSR 6/1/3.35', group: 'Bare', color: '#6b7280' },
'ACSR_6_1_472': { label: 'Bare ACSR 6/1/4.72', group: 'Bare', color: '#6b7280' },
'AAAC_7_250': { label: 'Bare AAAC 7/2.50', group: 'Bare', color: '#4b5563' },
'AAAC_7_315': { label: 'Bare AAAC 7/3.15', group: 'Bare', color: '#4b5563' },
'AAAC_7_381': { label: 'Bare AAAC 7/3.81', group: 'Bare', color: '#4b5563' },
'AAAC_7_426': { label: 'Bare AAAC 7/4.26', group: 'Bare', color: '#4b5563' },
'XLPE_35': { label: 'Insulated XLPE/AB Cable 35sqmm', group: 'Insulated', color: '#10b981' },
'XLPE_50': { label: 'Insulated XLPE/AB Cable 50sqmm', group: 'Insulated', color: '#10b981' },
'XLPE_70': { label: 'Insulated XLPE/AB Cable 70sqmm', group: 'Insulated', color: '#10b981' },
'XLPE_95': { label: 'Insulated XLPE/AB Cable 95sqmm', group: 'Insulated', color: '#10b981' },
'XLPE_120': { label: 'Insulated XLPE/AB Cable 120sqmm', group: 'Insulated', color: '#059669' },
'XLPE_185': { label: 'Insulated XLPE/AB Cable 185sqmm', group: 'Insulated', color: '#059669' }
};

const markerConfig = {
'dtr': { label: 'DTR', icon: '‚ò¢', mainType: ['HT', 'LT'], color: '#ef4444' },
'single_pole': { label: 'Single Pole', icon: '‚óØ', mainType: ['HT', 'LT'], color: '#3b82f6' },
'double_pole': { label: 'Double Pole', icon: '‚óØ‚óØ', mainType: ['HT'], color: '#a855f7' },
'three_pole': { label: '3-Pole', icon: '‚ó∞', mainType: ['HT'], color: '#f59e0b' }, // Using a simple structure icon
'four_pole': { label: '4-Pole', icon: '‚ó±', mainType: ['HT'], color: '#00704a' } // Using a simple structure icon
};

const gpsStatusElement = document.getElementById('gpsStatus');
const markerTypeSelectionElement = document.getElementById('markerTypeSelection');
const conductorTypeSelectElement = document.getElementById('conductorTypeSelect');


function calculateDistance(lat1, lon1, lat2, lon2) {
const R = 6371e3;
const œÜ1 = lat1 * Math.PI / 180;
const œÜ2 = lat2 * Math.PI / 180;
const ŒîœÜ = (lat2 - lat1) * Math.PI / 180;
const ŒîŒª = (lon2 - lon1) * Math.PI / 180;

const a = Math.sin(ŒîœÜ / 2) * Math.sin(ŒîœÜ / 2) +
Math.cos(œÜ1) * Math.cos(œÜ2) *
Math.sin(ŒîŒª / 2) * Math.sin(ŒîŒª / 2);
const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));

return R * c;
}

function updateTotalDistance() {
totalDistance = 0;
if (markers.length >= 2) {
for (let i = 1; i < markers.length; i++) {
if (!markers[i].isLineBreak) {
const dist = calculateDistance(
markers[i-1].lat, markers[i-1].lng,
markers[i].lat, markers[i].lng
);
markers[i].spanLength = dist;
totalDistance += dist;
} else if (markers[i].startFromMarkerId) {
if (markers[i].spanLength > 0) {
totalDistance += markers[i].spanLength;
}
} else {
markers[i].spanLength = 0;
}
}
markers[0].spanLength = 0;
} else if (markers.length === 1) {
markers[0].spanLength = 0;
}
}

function updateSiteName(name) {
siteName = name;
drawMap();
updateUI(); 
}

function updateSurveyType(type) {
    selectedSurveyType = type;
    drawMap();
    drawLeafletMap();
}

function startTracking() {
if (!navigator.geolocation) {
alert('Geolocation is not supported by your browser');
return;
}

isTracking = true;
isManualPosition = false;
startFromMarkerIndex = null;
startFromMarkerPosition = null;
initialFixAttempt = true;
document.getElementById('startBtn').style.display = 'none';
document.getElementById('stopBtn').style.display = 'flex';
document.getElementById('addMarkerBtn').disabled = true;

gpsStatusElement.textContent = 'Searching for high-accuracy GPS fix...';
gpsStatusElement.style.color = '#f97316';

initialFixTimeoutId = setTimeout(() => {
if (initialFixAttempt) {
gpsStatusElement.textContent = 'Warning: Low accuracy after 30 seconds. Proceeding with current accuracy.';
gpsStatusElement.style.color = '#dc2626';
document.getElementById('addMarkerBtn').disabled = false;
initialFixAttempt = false; 
}
}, INITIAL_FIX_TIMEOUT);

watchId = navigator.geolocation.watchPosition(
(position) => {
accuracy = position.coords.accuracy;

if (initialFixAttempt) {
if (accuracy <= ACCURACY_THRESHOLD) {
clearTimeout(initialFixTimeoutId);
initialFixAttempt = false;
document.getElementById('addMarkerBtn').disabled = false;
gpsStatusElement.textContent = `GPS Fix Achieved: ¬±${accuracy.toFixed(1)}m`;
gpsStatusElement.style.color = '#10b981';
} else {
gpsStatusElement.textContent = `Searching for high-accuracy GPS fix... (Current: ¬±${accuracy.toFixed(1)}m)`;
updateUI(); 
return; 
}
}

if (accuracy > MAX_ACCURACY_ERROR) {
console.warn('Point skipped due to poor accuracy:', accuracy.toFixed(1) + 'm');
updateUI();
return; 
}

const newPoint = {
lat: position.coords.latitude,
lng: position.coords.longitude,
timestamp: Date.now()
};

if (linePoints.length > 0) {
const lastPoint = linePoints[linePoints.length - 1];
const distanceMoved = calculateDistance(
lastPoint.lat, lastPoint.lng,
newPoint.lat, newPoint.lng
);

if (distanceMoved < MIN_MOVEMENT_DISTANCE) {
currentPosition = newPoint;
updateUI(); 
return; 
}
}

currentPosition = newPoint;
linePoints.push(newPoint); 

updateTotalDistance(); 

updateUI();
drawMap(); 
drawLeafletMap(); 
},
(error) => {
console.error('Error getting location:', error);
gpsStatusElement.textContent = `GPS Error: ${error.message}`;
gpsStatusElement.style.color = '#dc2626';
alert('Error getting location. Please enable GPS.');
stopTracking(); 
},
{
enableHighAccuracy: true,
timeout: 5000,
maximumAge: 0
}
);
}

function stopTracking() {
if (watchId) {
navigator.geolocation.clearWatch(watchId);
watchId = null;
}
clearTimeout(initialFixTimeoutId);
initialFixAttempt = false;
isTracking = false;
isManualPosition = false;
startFromMarkerIndex = null;
startFromMarkerPosition = null;
document.getElementById('startBtn').style.display = 'flex';
document.getElementById('stopBtn').style.display = 'none';
document.getElementById('addMarkerBtn').disabled = true;
gpsStatusElement.textContent = 'Tracking stopped.';
gpsStatusElement.style.color = '#6b7280';
}

function updateLineSubtype(subtype) {
selectedLineSubtype = subtype;
selectedLineMainType = lineConfig[subtype].mainType;
updateMarkerSelectors();
}

function updateConductorType(conductorKey) {
selectedConductorType = conductorKey;
drawMap();
drawLeafletMap();
}

function selectMarkerType(type) {
selectedMarkerType = type;
document.querySelectorAll('.marker-btn').forEach(btn => {
btn.classList.remove('active');
});
event.target.closest('.marker-btn').classList.add('active');
document.getElementById('markerTypeLabel').textContent = markerConfig[type].label;
}

function updateMarkerSelectors() {
markerTypeSelectionElement.innerHTML = ''; 
let firstMarkerKey = null;

for (const [key, config] of Object.entries(markerConfig)) {
if (config.mainType.includes(selectedLineMainType)) {
const isActive = (key === selectedMarkerType); 
if (firstMarkerKey === null) {
firstMarkerKey = key;
selectedMarkerType = key; // Auto-select the first available marker
document.getElementById('markerTypeLabel').textContent = config.label;
}

const button = document.createElement('button');
button.className = `marker-btn ${isActive ? 'active' : ''}`;
button.setAttribute('onclick', `selectMarkerType('${key}')`);
button.innerHTML = `
<div class="marker-icon">${config.icon}</div>
<div class="marker-label">${config.label}</div>
`;
markerTypeSelectionElement.appendChild(button);
}
}

if (!markerConfig[selectedMarkerType] || !markerConfig[selectedMarkerType].mainType.includes(selectedLineMainType)) {
selectedMarkerType = firstMarkerKey || 'dtr'; 
}

// Re-render to ensure the newly active button is visually active
document.querySelectorAll('.marker-btn').forEach(btn => {
btn.classList.remove('active');
if (btn.getAttribute('onclick').includes(`'${selectedMarkerType}'`)) {
btn.classList.add('active');
}
});

drawMap();
drawLeafletMap();
}

function populateConductorType() {
conductorTypeSelectElement.innerHTML = '';
let currentGroup = null;

for (const [key, config] of Object.entries(conductorConfig)) {
if (config.group !== currentGroup) {
const optgroup = document.createElement('optgroup');
optgroup.label = config.group + ' Conductor';
conductorTypeSelectElement.appendChild(optgroup);
currentGroup = config.group;
}

const option = document.createElement('option');
option.value = key;
option.textContent = config.label;
if (key === selectedConductorType) {
option.selected = true;
}
conductorTypeSelectElement.lastElementChild.appendChild(option);
}

if (!selectedConductorType || !conductorConfig[selectedConductorType]) {
selectedConductorType = Object.keys(conductorConfig)[0];
}
}


function startFromMarker(id) {
const markerIndex = markers.findIndex(m => m.id == id);
if (markerIndex === -1) return;

const marker = markers[markerIndex];

startFromMarkerIndex = markerIndex;
startFromMarkerPosition = {
lat: marker.lat,
lng: marker.lng
};

if (!isTracking) {
isTracking = true;
initialFixAttempt = false;
document.getElementById('startBtn').style.display = 'none';
document.getElementById('stopBtn').style.display = 'flex';
document.getElementById('addMarkerBtn').disabled = false;

gpsStatusElement.textContent = 'Starting GPS tracking...';
gpsStatusElement.style.color = '#f97316';

watchId = navigator.geolocation.watchPosition(
(position) => {
accuracy = position.coords.accuracy;

if (accuracy > MAX_ACCURACY_ERROR) {
console.warn('Point skipped due to poor accuracy:', accuracy.toFixed(1) + 'm');
updateUI();
return; 
}

const newPoint = {
lat: position.coords.latitude,
lng: position.coords.longitude,
timestamp: Date.now()
};

if (linePoints.length > 0) {
const lastPoint = linePoints[linePoints.length - 1];
const distanceMoved = calculateDistance(
lastPoint.lat, lastPoint.lng,
newPoint.lat, newPoint.lng
);

if (distanceMoved < MIN_MOVEMENT_DISTANCE) {
currentPosition = newPoint;
updateUI(); 
return; 
}
}

currentPosition = newPoint;
linePoints.push(newPoint); 

updateUI();
drawMap(); 
drawLeafletMap(); 

gpsStatusElement.textContent = `Starting from Marker #${markerIndex + 1}. Current accuracy: ¬±${accuracy.toFixed(1)}m. Move to your new location and click "Add ${markerConfig[selectedMarkerType].label}".`;
gpsStatusElement.style.color = '#a855f7';
},
(error) => {
console.error('Error getting location:', error);
gpsStatusElement.textContent = `GPS Error: ${error.message}`;
gpsStatusElement.style.color = '#dc2626';
},
{
enableHighAccuracy: true,
timeout: 5000,
maximumAge: 0
}
);
} else {
gpsStatusElement.textContent = `Starting from Marker #${markerIndex + 1}. Move to your new location and click "Add ${markerConfig[selectedMarkerType].label}".`;
gpsStatusElement.style.color = '#a855f7';
}

updateMarkersList();
drawMap();
drawLeafletMap();
}

function addMarker() {
if (!currentPosition && !startFromMarkerPosition) {
alert('Waiting for GPS position...');
return;
}

const positionToUse = currentPosition || startFromMarkerPosition;

if (!positionToUse) {
alert('No position available. Please wait for GPS.');
return;
}

const newMarker = {
id: Date.now(),
type: selectedMarkerType,
lineMainType: selectedLineMainType,
lineSubtype: selectedLineSubtype,
conductorType: selectedConductorType,
surveyType: selectedSurveyType, // Include survey type in marker data
lat: positionToUse.lat,
lng: positionToUse.lng,
timestamp: Date.now(),
spanLength: 0,
isLineBreak: false,
startFromMarkerId: null // Initialize explicitly
};

// If we're starting from an existing marker
if (startFromMarkerIndex !== null && startFromMarkerPosition) {
newMarker.isLineBreak = true;

const spanDistance = calculateDistance(
startFromMarkerPosition.lat,
startFromMarkerPosition.lng,
newMarker.lat,
newMarker.lng
);
newMarker.spanLength = spanDistance;
newMarker.startFromMarkerId = markers[startFromMarkerIndex].id;

console.log('Jump span created:', {
fromMarker: startFromMarkerIndex + 1,
toNewMarker: markers.length + 1,
distance: spanDistance.toFixed(2),
startFromMarkerId: newMarker.startFromMarkerId
});

// Clear the "start from" state
startFromMarkerIndex = null;
startFromMarkerPosition = null;
}

markers.push(newMarker);
updateTotalDistance(); 
updateUI();
drawMap();
drawLeafletMap();
updateMarkersList();

gpsStatusElement.textContent = 'Marker added successfully.';
gpsStatusElement.style.color = '#10b981';

if (isManualPosition) {
isManualPosition = false;
currentPosition = null;
document.getElementById('addMarkerBtn').disabled = true;
drawMap(); 
drawLeafletMap();
}
}

function clearAll() {
if (confirm('Clear all data? This cannot be undone.')) {
stopTracking();
linePoints = [];
markers = [];
totalDistance = 0;
currentPosition = null;
startFromMarkerIndex = null;
startFromMarkerPosition = null;
siteName = 'New Survey Site'; 
document.getElementById('siteNameInput').value = siteName;
updateUI();
drawMap();
drawLeafletMap(); 
updateMarkersList();
gpsStatusElement.textContent = '';
}
}

function updateUI() {
document.getElementById('totalDistance').textContent = totalDistance.toFixed(1) + 'm';
document.getElementById('pointsCount').textContent = linePoints.length;
document.getElementById('markersCount').textContent = markers.length;
document.getElementById('accuracy').textContent = accuracy ? `¬±${accuracy.toFixed(1)}m` : '--';

if (currentPosition || startFromMarkerPosition) {
document.getElementById('addMarkerBtn').disabled = false;
}

drawLeafletMap();
}

function updateMarkersList() {
const listCard = document.getElementById('markersListCard');
const list = document.getElementById('markersList');

if (markers.length === 0) {
listCard.style.display = 'none';
return;
}

listCard.style.display = 'block';
list.innerHTML = '';

markers.forEach((marker, idx) => {
const type = markerConfig[marker.type] || { label: 'Unknown', icon: '‚ùì' };
const lineInfo = lineConfig[marker.lineSubtype] || { label: 'Unknown Line', color: '#6b7280' };
const conductorInfo = conductorConfig[marker.conductorType] || { label: 'Unknown Conductor' };

let spanText = '';
if (marker.isLineBreak && marker.startFromMarkerId && marker.spanLength > 0) {
const startMarkerIdx = markers.findIndex(m => m.id === marker.startFromMarkerId);
spanText = `<span class="span-length" style="color:#a855f7;">Jump Span: ${marker.spanLength.toFixed(0)}m from #${startMarkerIdx + 1}</span>`;
} else if (idx > 0 && marker.spanLength && !marker.isLineBreak) {
spanText = `<span class="span-length">${marker.spanLength.toFixed(0)}m Span</span>`;
} else if (marker.isLineBreak && !marker.startFromMarkerId) {
spanText = '<span class="span-length" style="color:#dc2626;">New Segment Start (No Connection)</span>';
}

const item = document.createElement('div');
item.className = 'marker-item';

const startBtn = `<button class="btn btn-purple" style="padding: 5px 10px; font-size: 12px; height: 32px; margin-right: 8px; width: auto;" onclick="startFromMarker(${marker.id})">Start From Here</button>`;

item.innerHTML = `
<div class="marker-info">
<div class="marker-item-icon">${type.icon}</div>
<div class="marker-details">
<h4>${type.label} #${idx + 1} (${lineInfo.label} / ${conductorInfo.label}) ${spanText}</h4>
<div class="marker-coords">${marker.lat.toFixed(6)}, ${marker.lng.toFixed(6)}</div>
</div>
</div>
<div style="display:flex; align-items:center;">
${startBtn}
<button class="delete-btn" onclick="deleteMarker(${marker.id})">üóëÔ∏è</button>
</div>
`;
list.appendChild(item);
});
}

function deleteMarker(id) {
markers = markers.filter(m => m.id !== id);
updateTotalDistance(); 
updateUI();
drawMap();
drawLeafletMap();
updateMarkersList();
}

function offsetLatLng(lat, lng, dx, dy) {
const R = 6371e3;
const newLat = lat + (dy / R) * (180 / Math.PI);
const newLng = lng + (dx / (R * Math.cos(lat * Math.PI / 180))) * (180 / Math.PI);
return { lat: newLat, lng: newLng };
}

function drawMap() {
const canvas = document.getElementById('mapCanvas');
const ctx = canvas.getContext('2d');
const width = canvas.width;
const height = canvas.height;
const GRID_SIZE = 10; 

ctx.fillStyle = '#f0f9ff';
ctx.fillRect(0, 0, width, height);

ctx.fillStyle = '#1f2937';
ctx.font = 'bold 18px Arial';
ctx.textAlign = 'left';
ctx.fillText(`Site: ${siteName}`, 10, 25);
ctx.font = '14px Arial';
ctx.fillText(`Survey Type: ${selectedSurveyType === 'proposed' ? 'Proposed Line Survey' : 'Existing Line Survey'}`, 10, 45); // Display survey type

const pointsForBounds = [...markers, ...linePoints];

if (currentPosition && isManualPosition) {
pointsForBounds.push(currentPosition);
}

if (startFromMarkerPosition) {
pointsForBounds.push(startFromMarkerPosition);
}

if (pointsForBounds.length === 0) {
ctx.fillStyle = '#64748b';
ctx.font = '16px Arial';
ctx.textAlign = 'center';
ctx.fillText('Start tracking or add markers to see map', width / 2, height / 2);
return;
}

const lats = pointsForBounds.map(p => p.lat);
const lngs = pointsForBounds.map(p => p.lng);
const minLat = Math.min(...lats);
const maxLat = Math.max(...lats);
const minLng = Math.min(...lngs);
const maxLng = Math.max(...lngs);

const padding = 40;
const latRange = maxLat - minLat || 0.001;
const lngRange = maxLng - minLng || 0.001;

const scaleX = (width - 2 * padding) / lngRange;
const scaleY = (height - 2 * padding) / latRange;
const scale = Math.min(scaleX, scaleY);

const toX = (lng) => padding + (lng - minLng) * scale;
const toY = (lat) => height - padding - (lat - minLat) * scale;

if (minLat && minLng) {
const origin = { lat: minLat, lng: minLng };
const offsetN = offsetLatLng(origin.lat, origin.lng, 0, GRID_SIZE);
const offsetE = offsetLatLng(origin.lat, origin.lng, GRID_SIZE, 0);
const latStep = offsetN.lat - origin.lat;
const lngStep = offsetE.lng - origin.lng;

ctx.strokeStyle = 'rgba(150, 150, 150, 0.5)';
ctx.lineWidth = 0.5;

let currentLat = minLat - (latRange/10); 
while (currentLat <= maxLat + (latRange/10)) {
ctx.beginPath();
const y = toY(currentLat);
ctx.moveTo(0, y);
ctx.lineTo(width, y);
ctx.stroke();
currentLat += latStep;
}

let currentLng = minLng - (lngRange/10); 
while (currentLng <= maxLng + (lngRange/10)) {
ctx.beginPath();
const x = toX(currentLng);
ctx.moveTo(x, 0);
ctx.lineTo(x, height);
ctx.stroke();
currentLng += lngStep;
}

ctx.fillStyle = 'rgba(100, 100, 100, 0.8)';
ctx.font = '10px Arial';
ctx.textAlign = 'right';
ctx.fillText(`Grid: ${GRID_SIZE}m x ${GRID_SIZE}m`, width - 10, height - 10);
}


// --- Dotted/Solid Line Logic for Markers ---
const isProposed = selectedSurveyType === 'proposed';
const dashPattern = isProposed ? [10, 5] : []; 

if (linePoints.length > 1) {
ctx.strokeStyle = '#d1d5db'; 
ctx.lineWidth = 1;
ctx.beginPath();
ctx.moveTo(toX(linePoints[0].lng), toY(linePoints[0].lat));
for (let i = 1; i < linePoints.length; i++) {
ctx.lineTo(toX(linePoints[i].lng), toY(linePoints[i].lat));
}
ctx.stroke();
}

if (markers.length > 1) {
for (let i = 1; i < markers.length; i++) {
const prevMarker = markers[i - 1];
const currentMarker = markers[i];

if (currentMarker.isLineBreak) {
if (currentMarker.startFromMarkerId) {
const startMarker = markers.find(m => m.id === currentMarker.startFromMarkerId);
if (startMarker) {
const spanColor = lineConfig[currentMarker.lineSubtype] ? lineConfig[currentMarker.lineSubtype].color : '#3b82f6';

ctx.strokeStyle = spanColor; 
ctx.lineWidth = 3;
ctx.setLineDash(dashPattern); // APPLY DASH PATTERN FOR JUMP
ctx.beginPath();
ctx.moveTo(toX(startMarker.lng), toY(startMarker.lat));
ctx.lineTo(toX(currentMarker.lng), toY(currentMarker.lat));
ctx.stroke();
ctx.setLineDash([]); // Reset to solid
}
}
continue; 
}

const spanColor = lineConfig[currentMarker.lineSubtype] ? lineConfig[currentMarker.lineSubtype].color : '#3b82f6';

ctx.strokeStyle = spanColor; 
ctx.lineWidth = 3;
ctx.setLineDash(dashPattern); // APPLY DASH PATTERN FOR MAIN LINE
ctx.beginPath();
ctx.moveTo(toX(prevMarker.lng), toY(prevMarker.lat));
ctx.lineTo(toX(currentMarker.lng), toY(currentMarker.lat));
ctx.stroke();
ctx.setLineDash([]); // Reset to solid
}
}
// --- End Dotted/Solid Line Logic ---

if (startFromMarkerPosition && currentPosition) {
ctx.strokeStyle = '#a855f7';
ctx.lineWidth = 2;
ctx.setLineDash([5, 5]);
ctx.beginPath();
ctx.moveTo(toX(startFromMarkerPosition.lng), toY(startFromMarkerPosition.lat));
ctx.lineTo(toX(currentPosition.lng), toY(currentPosition.lat));
ctx.stroke();
ctx.setLineDash([]);

const dist = calculateDistance(
startFromMarkerPosition.lat, startFromMarkerPosition.lng,
currentPosition.lat, currentPosition.lng
);
const midX = (toX(startFromMarkerPosition.lng) + toX(currentPosition.lng)) / 2;
const midY = (toY(startFromMarkerPosition.lat) + toY(currentPosition.lat)) / 2;

ctx.fillStyle = '#ffffff';
ctx.fillRect(midX - 30, midY - 10, 60, 20);

ctx.fillStyle = '#a855f7';
ctx.font = 'bold 12px Arial';
ctx.textAlign = 'center';
ctx.textBaseline = 'middle';
ctx.fillText(`${dist.toFixed(0)}m`, midX, midY);
}

markers.forEach((marker, idx) => {
// ... (marker drawing logic remains the same)
const type = markerConfig[marker.type] || { icon: '‚ùì', color: '#6b7280' };
const line = lineConfig[marker.lineSubtype] || { color: '#3b82f6' };
const x = toX(marker.lng);
const y = toY(marker.lat);
const markerNumber = idx + 1;

let markerColor = line.color; 
if (marker.type === 'dtr') {
markerColor = markerConfig.dtr.color;
}

ctx.strokeStyle = markerColor;
ctx.lineWidth = 2;
ctx.beginPath();
ctx.arc(x, y, 15, 0, Math.PI * 2);
ctx.stroke();

ctx.font = '24px Arial';
ctx.textAlign = 'center';
ctx.textBaseline = 'middle';
ctx.fillText(type.icon, x, y);

ctx.fillStyle = '#1f2937';
ctx.font = 'bold 12px Arial';
ctx.textAlign = 'left';
ctx.textBaseline = 'top';
ctx.fillText(markerNumber, x + 18, y - 10);

if (idx > 0 && marker.spanLength > 0 && !marker.isLineBreak) {
const prevMarker = markers[idx - 1];
const prevX = toX(prevMarker.lng);
const prevY = toY(prevMarker.lat);
const midX = (x + prevX) / 2;
const midY = (y + prevY) / 2;

const spanColor = lineConfig[marker.lineSubtype] ? lineConfig[marker.lineSubtype].color : '#3b82f6';

ctx.fillStyle = '#ffffff';
ctx.fillRect(midX - 25, midY - 10, 50, 20); 

ctx.fillStyle = spanColor;
ctx.font = 'bold 12px Arial';
ctx.textAlign = 'center';
ctx.textBaseline = 'middle';
ctx.fillText(`${marker.spanLength.toFixed(0)}m`, midX, midY);
} else if (marker.isLineBreak && marker.startFromMarkerId && marker.spanLength > 0) {
const startMarker = markers.find(m => m.id === marker.startFromMarkerId);
if (startMarker) {
const startX = toX(startMarker.lng);
const startY = toY(startMarker.lat);
const midX = (x + startX) / 2;
const midY = (y + startY) / 2;

const spanColor = lineConfig[marker.lineSubtype] ? lineConfig[marker.lineSubtype].color : '#3b82f6';

ctx.fillStyle = '#ffffff';
ctx.fillRect(midX - 25, midY - 10, 50, 20);

ctx.fillStyle = spanColor;
ctx.font = 'bold 12px Arial';
ctx.textAlign = 'center';
ctx.textBaseline = 'middle';
ctx.fillText(`${marker.spanLength.toFixed(0)}m`, midX, midY);
}
}
});

if (currentPosition) {
const x = toX(currentPosition.lng);
const y = toY(currentPosition.lat);

if (isManualPosition) {
ctx.fillStyle = '#a855f7';
ctx.strokeStyle = '#ffffff';
ctx.lineWidth = 3;
ctx.beginPath();
ctx.arc(x, y, 10, 0, Math.PI * 2);
ctx.fill();
ctx.stroke();

ctx.fillStyle = '#ffffff';
ctx.font = 'bold 12px Arial';
ctx.fillText('START', x, y + 1);
} else {
ctx.fillStyle = '#10b981';
ctx.beginPath();
ctx.arc(x, y, 8, 0, Math.PI * 2);
ctx.fill();

ctx.strokeStyle = '#ffffff';
ctx.lineWidth = 2;
ctx.stroke();
}
}
}

function initLeafletMap() {
let centerLat = 31.7831; 
let centerLng = 76.9926; 
if (markers.length > 0) {
centerLat = markers[0].lat;
centerLng = markers[0].lng;
} else if (currentPosition) {
centerLat = currentPosition.lat;
centerLng = currentPosition.lng;
}

if (leafletMapInstance) {
leafletMapInstance.remove();
}

leafletMapInstance = L.map('leafletMap').setView([centerLat, centerLng], 15);

satelliteTiles = L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', {
attribution: 'Tiles &copy; Esri'
}).addTo(leafletMapInstance);

mapTiles = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
attribution: '&copy; OpenStreetMap contributors'
});

const baseMaps = {
"Satellite View": satelliteTiles,
"Street Map": mapTiles
};
L.control.layers(baseMaps).addTo(leafletMapInstance);

drawLeafletMap();
}

function drawLeafletMap() {
if (!leafletMapInstance) {
initLeafletMap();
return;
}

leafletMarkers.forEach(m => m.remove());
leafletMarkers = [];
leafletPolylines.forEach(p => p.remove());
leafletPolylines = [];

let segmentCoordinates = [];
let currentSegmentColor = lineConfig[selectedLineSubtype] ? lineConfig[selectedLineSubtype].color : '#3b82f6';

const isProposed = selectedSurveyType === 'proposed';
const dashArray = isProposed ? '8, 8' : null; // Solid line if existing, dotted if proposed

for (let i = 0; i < markers.length; i++) {
const marker = markers[i];
const markerLineConfig = lineConfig[marker.lineSubtype] || { color: '#3b82f6' };

if (i > 0) {
const prevMarker = markers[i - 1];

if (!marker.isLineBreak) {
segmentCoordinates.push([marker.lat, marker.lng]);

let nextSegmentColor = markerLineConfig.color;

if (nextSegmentColor !== currentSegmentColor || i === markers.length - 1) {
const polyline = L.polyline(segmentCoordinates, {
color: currentSegmentColor, 
weight: 4,
opacity: 1.0,
dashArray: dashArray // Apply line style
}).addTo(leafletMapInstance);
leafletPolylines.push(polyline);

if (nextSegmentColor !== currentSegmentColor) {
segmentCoordinates = [[prevMarker.lat, prevMarker.lng], [marker.lat, marker.lng]];
currentSegmentColor = nextSegmentColor;
}
}
} else {
if (marker.startFromMarkerId) {
const startMarker = markers.find(m => m.id === marker.startFromMarkerId);
if (startMarker) {
const jumpLine = L.polyline(
[[startMarker.lat, startMarker.lng], [marker.lat, marker.lng]],
{
color: markerLineConfig.color,
weight: 4,
opacity: 1.0,
dashArray: dashArray // Apply line style for jump span
}
).addTo(leafletMapInstance);
leafletPolylines.push(jumpLine);
}
}

segmentCoordinates = [[marker.lat, marker.lng]];
currentSegmentColor = markerLineConfig.color;
}
} else {
segmentCoordinates.push([marker.lat, marker.lng]);
currentSegmentColor = markerLineConfig.color;
}

if (i === markers.length - 1 && segmentCoordinates.length > 1) {
const polyline = L.polyline(segmentCoordinates, {
color: currentSegmentColor,
weight: 4,
opacity: 1.0,
dashArray: dashArray // Apply line style for final segment
}).addTo(leafletMapInstance);
leafletPolylines.push(polyline);
}
}

if (startFromMarkerPosition && currentPosition) {
const previewLine = L.polyline(
[[startFromMarkerPosition.lat, startFromMarkerPosition.lng], 
[currentPosition.lat, currentPosition.lng]],
{
color: '#a855f7',
weight: 3,
opacity: 0.7,
dashArray: '5, 10'
}
).addTo(leafletMapInstance);
leafletPolylines.push(previewLine);
}

markers.forEach((marker, idx) => {
const type = markerConfig[marker.type] || { label: 'Unknown', icon: '‚ùì' };
const line = lineConfig[marker.lineSubtype] || { label: 'Unknown Line', color: '#3b82f6' };
const conductor = conductorConfig[marker.conductorType] || { label: 'Unknown Conductor' };
const markerNumber = idx + 1;

let markerColor = line.color; 
if (marker.type === 'dtr') {
markerColor = markerConfig.dtr.color;
}

const spanText = (idx > 0 && marker.spanLength && !marker.isLineBreak) ? `${marker.spanLength.toFixed(0)}m Span` : (marker.isLineBreak && marker.spanLength > 0 ? `${marker.spanLength.toFixed(0)}m Span (Jump)` : marker.isLineBreak ? 'New Segment Start' : '');

const markerIcon = L.divIcon({
className: 'custom-marker',
html: `<div style="background-color: ${markerColor}; border: 3px solid white; color: white; border-radius: 50%; width: 30px; height: 30px; line-height: 25px; text-align: center; font-weight: bold; font-size: 14px;">${markerNumber}</div>`,
iconSize: [30, 30],
iconAnchor: [15, 15]
});

const lMarker = L.marker([marker.lat, marker.lng], {
icon: markerIcon,
title: `${type.label} #${markerNumber}`
}).addTo(leafletMapInstance);

lMarker.bindPopup(`
<div style="font-family: Arial; padding: 5px;">
<strong>${type.label} #${markerNumber}</strong><br>
Survey: ${marker.surveyType === 'proposed' ? 'Proposed' : 'Existing'}<br>
Line: ${line.label}<br>
Conductor: ${conductor.label}<br>
Lat: ${marker.lat.toFixed(6)}, Lng: ${marker.lng.toFixed(6)}<br>
${spanText}
</div>
`);

leafletMarkers.push(lMarker);
});

if (currentPosition) {
let currentMarker;
if (isManualPosition) {
currentMarker = L.circleMarker([currentPosition.lat, currentPosition.lng], {
radius: 8,
color: '#a855f7',
fillColor: '#a855f7',
fillOpacity: 1,
weight: 3
}).bindPopup('Manual Start Location').addTo(leafletMapInstance);
} else {
currentMarker = L.circleMarker([currentPosition.lat, currentPosition.lng], {
radius: 5,
color: '#ffffff',
fillColor: '#10b981',
fillOpacity: 1,
weight: 2
}).bindPopup(`Live GPS: ¬±${accuracy.toFixed(1)}m`).addTo(leafletMapInstance);
}
leafletMarkers.push(currentMarker);
}

if (markers.length > 0) {
const allLatLngs = markers.map(m => [m.lat, m.lng]);
if (currentPosition) allLatLngs.push([currentPosition.lat, currentPosition.lng]);
if (startFromMarkerPosition) allLatLngs.push([startFromMarkerPosition.lat, startFromMarkerPosition.lng]);

if (allLatLngs.length > 1) {
leafletMapInstance.fitBounds(allLatLngs, { padding: [30, 30] });
} else if (allLatLngs.length === 1) {
leafletMapInstance.setView(allLatLngs[0], 17);
}
}
}

function saveToJSON() {
const data = {
version: '3.8_dynamic',
created: new Date().toISOString(),
siteName: siteName, 
surveyType: selectedSurveyType, // Save Survey Type
totalDistance: totalDistance, 
linePoints: linePoints,
markers: markers.map((m, idx) => ({
...m,
index: idx + 1,
markerTypeLabel: (markerConfig[m.type] || {}).label || 'N/A',
lineMainTypeLabel: (lineConfig[m.lineSubtype] || {}).mainType || 'N/A',
lineSubtypeLabel: (lineConfig[m.lineSubtype] || {}).label || 'N/A',
conductorTypeLabel: (conductorConfig[m.conductorType] || {}).label || 'N/A',
spanLength: m.spanLength ? m.spanLength.toFixed(2) : 'N/A',
isLineBreak: m.isLineBreak || false,
surveyType: m.surveyType || selectedSurveyType // Ensure survey type is saved
}))
};

const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
const url = URL.createObjectURL(blob);
const a = document.createElement('a');
a.href = url;
a.download = `${siteName.replace(/[^a-z0-9]/gi, '_')}-survey-v3-8-dynamic-${Date.now()}.json`;
a.click();
URL.revokeObjectURL(url);
}

function loadFromJSON(event) {
const file = event.target.files[0];
if (!file) return;

const reader = new FileReader();
reader.onload = (e) => {
try {
const data = JSON.parse(e.target.result);
linePoints = data.linePoints || [];

// Load survey type from data, default to 'proposed'
selectedSurveyType = data.surveyType || 'proposed';
document.querySelector(`input[name="surveyType"][value="${selectedSurveyType}"]`).checked = true;


markers = (data.markers || []).map(m => ({
id: m.id || Date.now(),
type: m.type || 'single_pole',
lineMainType: m.lineMainType || (m.lineSubtype || 'HT_11kV').split('_')[0],
lineSubtype: m.lineSubtype || 'HT_11kV',
conductorType: m.conductorType || 'ACSR_6_1_472',
surveyType: m.surveyType || selectedSurveyType, // Ensure survey type is loaded/set
lat: m.lat,
lng: m.lng,
timestamp: m.timestamp || Date.now(),
spanLength: m.spanLength ? parseFloat(m.spanLength) : 0,
isLineBreak: m.isLineBreak || false,
startFromMarkerId: m.startFromMarkerId || null
})); 
siteName = data.siteName || 'New Survey Site'; 
document.getElementById('siteNameInput').value = siteName; 

// Set current selection based on last marker or default
if (markers.length > 0) {
const lastMarker = markers[markers.length - 1];
selectedLineSubtype = lastMarker.lineSubtype;
selectedConductorType = lastMarker.conductorType;
selectedMarkerType = lastMarker.type;

// Update Radio Buttons and Dropdown
document.querySelector(`input[name="lineType"][value="${selectedLineSubtype}"]`).checked = true;
conductorTypeSelectElement.value = selectedConductorType;
}

// Initial setup to match loaded data
updateLineSubtype(selectedLineSubtype); // This calls updateMarkerSelectors

updateTotalDistance(); 
updateUI();
drawMap();
drawLeafletMap(); 
updateMarkersList();
alert(`Survey data loaded successfully! (Version: ${data.version || 'Unknown'})`);
} catch (error) {
console.error("Load JSON Error:", error);
alert('Error loading file. Please check the file format.');
}
};
reader.readAsText(file);
event.target.value = '';
}


function exportToPNG() {
    if (markers.length === 0) {
        alert('No markers to export.');
        return;
    }

    // A3 Dimensions (pixels at high resolution for printing)
    const A3_WIDTH = 3000;
    const A3_HEIGHT = 4242; 
    const PADDING = 150;
    const MAP_WIDTH = A3_WIDTH - 2 * PADDING;
    const MAP_HEIGHT = MAP_WIDTH * (500/800); // Maintain map aspect ratio
    const FONT_SCALE = 3.75; // 3000 / 800

    // Capture the current map canvas
    const canvas = document.getElementById('mapCanvas');
    const tempCanvas = document.createElement('canvas');
    tempCanvas.width = A3_WIDTH;
    tempCanvas.height = A3_HEIGHT; 
    const pdfCanvas = tempCanvas;
    const pdfCtx = pdfCanvas.getContext('2d');

    pdfCtx.fillStyle = '#ffffff';
    pdfCtx.fillRect(0, 0, A3_WIDTH, A3_HEIGHT);

    // --- Header Section ---
    pdfCtx.fillStyle = '#1f2937';
    pdfCtx.font = `bold ${30 * FONT_SCALE}px Arial`;
    pdfCtx.textAlign = 'center';
    pdfCtx.fillText(siteName, A3_WIDTH / 2, 50 * FONT_SCALE);

    pdfCtx.font = `${16 * FONT_SCALE}px Arial`;
    pdfCtx.fillText(`Total Marked Points: ${markers.length} | Total Survey Distance: ${(totalDistance / 1000).toFixed(3)} km`, A3_WIDTH / 2, 75 * FONT_SCALE);

    pdfCtx.fillStyle = '#3b82f6';
    pdfCtx.fillRect(PADDING, 95 * FONT_SCALE, MAP_WIDTH, 5 * FONT_SCALE); 

    // --- Survey Info ---
    let currentY = 125 * FONT_SCALE;
    pdfCtx.fillStyle = '#1f2937';
    pdfCtx.font = `bold ${18 * FONT_SCALE}px Arial`;
    pdfCtx.textAlign = 'left';
    pdfCtx.fillText('I. Survey Information:', PADDING, currentY);
    currentY += 25 * FONT_SCALE;
    pdfCtx.font = `${14 * FONT_SCALE}px Arial`;
    pdfCtx.fillText(`Type: ${selectedSurveyType === 'proposed' ? 'Proposed Line' : 'Existing Line'}`, PADDING, currentY);
    currentY += 20 * FONT_SCALE;
    pdfCtx.fillText(`Generated On: ${new Date().toLocaleString()}`, PADDING, currentY);
    currentY += 20 * FONT_SCALE;

    // --- Map Title ---
    currentY += 10 * FONT_SCALE;
    pdfCtx.font = `bold ${18 * FONT_SCALE}px Arial`;
    pdfCtx.fillText('II. Survey Map (Schematic View):', PADDING, currentY);
    currentY += 10 * FONT_SCALE;

    const mapYStart = currentY; 
    
    // Draw the main map canvas
    pdfCtx.drawImage(canvas, PADDING, mapYStart, MAP_WIDTH, MAP_HEIGHT);

    // --- Legend Section (Two Columns) ---
    let LEGEND_BLOCK_Y = mapYStart + MAP_HEIGHT + (30 * FONT_SCALE); // Start Y for the legend block
    const LEGEND_X1 = PADDING;
    const LEGEND_X2 = A3_WIDTH / 2; // Starting X for the second column

    // --- Column 1: Line Type Color Legend ---
    let lineY = LEGEND_BLOCK_Y;
    pdfCtx.fillStyle = '#1f2937';
    pdfCtx.font = `bold ${16 * FONT_SCALE}px Arial`;
    pdfCtx.fillText('Line Type Color Legend:', LEGEND_X1, lineY);
    lineY += 25 * FONT_SCALE;

    Object.keys(lineConfig).forEach(key => {
        const ptype = lineConfig[key];
        pdfCtx.fillStyle = ptype.color;
        pdfCtx.fillRect(LEGEND_X1, lineY - (10 * FONT_SCALE), 20 * FONT_SCALE, 10 * FONT_SCALE);
        pdfCtx.fillStyle = '#000000';
        pdfCtx.font = `${14 * FONT_SCALE}px Arial`;
        pdfCtx.fillText(ptype.label, LEGEND_X1 + (30 * FONT_SCALE), lineY);
        lineY += 20 * FONT_SCALE;
    });

    // --- Column 2: Symbol Description ---
    let symbolY = LEGEND_BLOCK_Y;
    pdfCtx.fillStyle = '#1f2937';
    pdfCtx.font = `bold ${16 * FONT_SCALE}px Arial`;
    pdfCtx.fillText('Symbol Description:', LEGEND_X2, symbolY);
    symbolY += 30 * FONT_SCALE;

    Object.values(markerConfig).forEach(type => {
        pdfCtx.font = `${24 * FONT_SCALE}px Arial`;
        pdfCtx.fillText(type.icon, LEGEND_X2, symbolY);
        pdfCtx.font = `${14 * FONT_SCALE}px Arial`;
        pdfCtx.fillText(type.label, LEGEND_X2 + (40 * FONT_SCALE), symbolY - (5 * FONT_SCALE));
        symbolY += 30 * FONT_SCALE;
    });

    // --- Data Note (Replaces Conductor List and GPS Coordinates/Span List) ---
    // Ensure the message starts below the lowest part of the legends
    let maxLegendY = Math.max(lineY, symbolY);
    let messageY = maxLegendY + (40 * FONT_SCALE);

    pdfCtx.font = `bold ${16 * FONT_SCALE}px Arial`;
    pdfCtx.fillStyle = '#1f2937';
    pdfCtx.textAlign = 'left';
    pdfCtx.fillText('III. Data Note:', PADDING, messageY);
    messageY += 20 * FONT_SCALE;
    pdfCtx.font = `italic ${14 * FONT_SCALE}px Arial`;
    pdfCtx.fillStyle = '#6b7280';
    pdfCtx.fillText('Detailed GPS Coordinates, Span lengths, and Conductor List are exclusively available in the exported CSV and JSON files.', PADDING, messageY);

    // --- Footer Section ---
    const footerY = A3_HEIGHT - (40 * FONT_SCALE);
    pdfCtx.fillStyle = '#1f2937';
    pdfCtx.font = `${10 * FONT_SCALE}px Arial`;
    pdfCtx.textAlign = 'center';
    pdfCtx.fillText('Electrical Line Survey App | Version 3.8 (Dynamic) | Generated for A3 Print', A3_WIDTH / 2, footerY);
    pdfCtx.fillText('¬© 2025‚Äì26 ErAjay Kumar . All rights reserved.', A3_WIDTH / 2, footerY + (10 * FONT_SCALE));
    pdfCtx.fillText('Developed for Professional Field Use | For technical support, contact +91-70187-56182/ErAjay.HPSEB@gmail.com', A3_WIDTH / 2, footerY + (20 * FONT_SCALE));

    // --- Export ---
    pdfCanvas.toBlob((blob) => {
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `${siteName.replace(/[^a-z0-9]/gi, '_')}-report-v3-8-dynamic-A3-${Date.now()}.png`;
        a.click();
        URL.revokeObjectURL(url);
        alert('Report exported successfully as A3 PNG image!');
    });
}

function exportToDetailedPNG() {
    if (markers.length === 0) {
        alert('No markers to export.');
        return;
    }

    // A3 Dimensions (pixels at high resolution for printing)
    const A3_WIDTH = 3000;
    const A3_HEIGHT = 4242; 
    const PADDING = 150;
    const MAP_WIDTH = A3_WIDTH - 2 * PADDING;
    const MAP_HEIGHT = MAP_WIDTH * (500/800); 
    const FONT_SCALE = 3.75; 

    // Capture the current map canvas
    const canvas = document.getElementById('mapCanvas');
    const tempCanvas = document.createElement('canvas');
    tempCanvas.width = A3_WIDTH;
    tempCanvas.height = A3_HEIGHT; 
    const pdfCanvas = tempCanvas;
    const pdfCtx = pdfCanvas.getContext('2d');

    pdfCtx.fillStyle = '#ffffff';
    pdfCtx.fillRect(0, 0, A3_WIDTH, A3_HEIGHT);

    // --- Header Section ---
    pdfCtx.fillStyle = '#1f2937';
    pdfCtx.font = `bold ${30 * FONT_SCALE}px Arial`;
    pdfCtx.textAlign = 'center';
    pdfCtx.fillText(`${siteName} - Detailed Report`, A3_WIDTH / 2, 50 * FONT_SCALE);

    pdfCtx.font = `${16 * FONT_SCALE}px Arial`;
    pdfCtx.fillText(`Total Marked Points: ${markers.length} | Total Survey Distance: ${(totalDistance / 1000).toFixed(3)} km`, A3_WIDTH / 2, 75 * FONT_SCALE);

    pdfCtx.fillStyle = '#3b82f6';
    pdfCtx.fillRect(PADDING, 95 * FONT_SCALE, MAP_WIDTH, 5 * FONT_SCALE); 

    // --- Survey Info ---
    let currentY = 125 * FONT_SCALE;
    pdfCtx.fillStyle = '#1f2937';
    pdfCtx.font = `bold ${18 * FONT_SCALE}px Arial`;
    pdfCtx.textAlign = 'left';
    pdfCtx.fillText('I. Survey Information:', PADDING, currentY);
    currentY += 25 * FONT_SCALE;
    pdfCtx.font = `${14 * FONT_SCALE}px Arial`;
    pdfCtx.fillText(`Type: ${selectedSurveyType === 'proposed' ? 'Proposed Line' : 'Existing Line'}`, PADDING, currentY);
    currentY += 20 * FONT_SCALE;
    pdfCtx.fillText(`Generated On: ${new Date().toLocaleString()}`, PADDING, currentY);
    currentY += 20 * FONT_SCALE;

    // --- Map Title ---
    currentY += 10 * FONT_SCALE;
    pdfCtx.font = `bold ${18 * FONT_SCALE}px Arial`;
    pdfCtx.fillText('II. Survey Map (Schematic View):', PADDING, currentY);
    currentY += 10 * FONT_SCALE;

    const mapYStart = currentY; 
    
    // Draw the main map canvas
    pdfCtx.drawImage(canvas, PADDING, mapYStart, MAP_WIDTH, MAP_HEIGHT);
    currentY = mapYStart + MAP_HEIGHT;

    // --- Data Note (Replaces all detailed data) ---
    currentY += 40 * FONT_SCALE;
    pdfCtx.font = `bold ${18 * FONT_SCALE}px Arial`;
    pdfCtx.fillStyle = '#1f2937';
    pdfCtx.textAlign = 'left';
    pdfCtx.fillText('III. Detailed Survey Data:', PADDING, currentY);
    currentY += 25 * FONT_SCALE;
    pdfCtx.font = `italic ${16 * FONT_SCALE}px Arial`;
    pdfCtx.fillStyle = '#ef4444';
    pdfCtx.fillText('*** NOTE: Detailed GPS Coordinates, Conductor List, and Span-by-Span Data ***', PADDING, currentY);
    currentY += 25 * FONT_SCALE;
    pdfCtx.fillText('*** are intentionally omitted from this PNG report to maintain a concise overview and avoid file size issues. ***', PADDING, currentY);
    currentY += 25 * FONT_SCALE;
    pdfCtx.fillStyle = '#6b7280';
    pdfCtx.fillText('Please use the exported **CSV** or **JSON** files for all tabular and detailed spatial data.', PADDING, currentY);
    currentY += 25 * FONT_SCALE;
    
    // --- Legend (Simplified in Detailed Report) ---
    currentY += 40 * FONT_SCALE;
    pdfCtx.fillStyle = '#1f2937';
    pdfCtx.font = `bold ${18 * FONT_SCALE}px Arial`;
    pdfCtx.fillText('IV. Legend:', PADDING, currentY);
    currentY += 25 * FONT_SCALE;
    
    // Using the same two-column structure as the main PNG
    let lineY = currentY;
    let symbolY = currentY;
    const LEGEND_X2 = A3_WIDTH / 2;

    // Column 1: Line Type Color Legend
    pdfCtx.fillStyle = '#1f2937';
    pdfCtx.font = `bold ${16 * FONT_SCALE}px Arial`;
    pdfCtx.fillText('Line Type Color Legend:', PADDING, lineY);
    lineY += 25 * FONT_SCALE;

    Object.keys(lineConfig).forEach(key => {
        const ptype = lineConfig[key];
        pdfCtx.fillStyle = ptype.color;
        pdfCtx.fillRect(PADDING, lineY - (10 * FONT_SCALE), 20 * FONT_SCALE, 10 * FONT_SCALE);
        pdfCtx.fillStyle = '#000000';
        pdfCtx.font = `${14 * FONT_SCALE}px Arial`;
        pdfCtx.fillText(ptype.label, PADDING + (30 * FONT_SCALE), lineY);
        lineY += 20 * FONT_SCALE;
    });

    // Column 2: Symbol Description 
    pdfCtx.fillStyle = '#1f2937';
    pdfCtx.font = `bold ${16 * FONT_SCALE}px Arial`;
    pdfCtx.fillText('Symbol Description:', LEGEND_X2, symbolY);
    symbolY += 30 * FONT_SCALE;

    Object.values(markerConfig).forEach(type => {
        pdfCtx.font = `${24 * FONT_SCALE}px Arial`;
        pdfCtx.fillText(type.icon, LEGEND_X2, symbolY);
        pdfCtx.font = `${14 * FONT_SCALE}px Arial`;
        pdfCtx.fillText(type.label, LEGEND_X2 + (40 * FONT_SCALE), symbolY - (5 * FONT_SCALE));
        symbolY += 30 * FONT_SCALE;
    });
    
    // --- Footer Section ---
    const footerY = A3_HEIGHT - (40 * FONT_SCALE);
    pdfCtx.fillStyle = '#1f2937';
    pdfCtx.font = `${10 * FONT_SCALE}px Arial`;
    pdfCtx.textAlign = 'center';
    pdfCtx.fillText('Electrical Line Survey App | Version 3.8 (Dynamic) | Generated for A3 Print', A3_WIDTH / 2, footerY);
    pdfCtx.fillText('¬© 2025‚Äì26 ErAjay Kumar . All rights reserved.', A3_WIDTH / 2, footerY + (10 * FONT_SCALE));
    pdfCtx.fillText('Developed for Professional Field Use | For technical support, contact +91-70187-56182/ErAjay.HPSEB@gmail.com', A3_WIDTH / 2, footerY + (20 * FONT_SCALE));

    // --- Export ---
    pdfCanvas.toBlob((blob) => {
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `${siteName.replace(/[^a-z0-9]/gi, '_')}-detailed-report-v3-8-dynamic-A3-${Date.now()}.png`;
        a.click();
        URL.revokeObjectURL(url);
        alert('Detailed report exported successfully as A3 PNG image!');
    });
}



function exportToCSV() {
  if (markers.length === 0) {
    alert('No markers to export.');
    return;
  }

  let csvContent = "Site Name,Survey Type,Span Description,Marker #,Type,Line Main Type,Line Subtype,Conductor Type,Latitude,Longitude,Span Length (m),Connected From Marker,Progressive Total Length (m),Line Break\n"; // ADDED Survey Type

  let cumulativeDistance = 0;

  markers.forEach((marker, idx) => {
    const markerNumber = idx + 1;
    const typeLabel = (markerConfig[marker.type] || {}).label || 'N/A';
    const lineMainTypeLabel = marker.lineMainType || 'N/A';
    const lineSubtypeLabel = (lineConfig[marker.lineSubtype] || {}).label || 'N/A';
    const conductorTypeLabel = (conductorConfig[marker.conductorType] || {}).label || 'N/A';
    const surveyTypeLabel = marker.surveyType === 'proposed' ? 'Proposed' : 'Existing';

    const span = marker.spanLength || 0; 
    const lat = marker.lat.toFixed(6);
    const lng = marker.lng.toFixed(6);
    const isLineBreak = marker.isLineBreak ? 'YES' : 'NO';

    let connectedFrom = '';
    if (marker.isLineBreak && marker.startFromMarkerId) {
      const startMarker = markers.find(m => m.id === marker.startFromMarkerId);
      const startMarkerIdx = markers.findIndex(m => m.id === marker.startFromMarkerId);
      connectedFrom = `${(markerConfig[startMarker.type] || {}).label} #${startMarkerIdx + 1} (Jump)`;
    } else if (!marker.isLineBreak && idx > 0) {
      connectedFrom = `${(markerConfig[markers[idx - 1].type] || {}).label} #${idx}`;
    } else {
      connectedFrom = 'N/A';
    }

    if (span > 0 && !marker.isLineBreak) {
      if (idx > 0 && markers[idx-1].lineSubtype === marker.lineSubtype) {
        cumulativeDistance += span;
      }
    } else if (marker.isLineBreak && span > 0) {
        cumulativeDistance += span;
    }


    const spanText = (idx === 0) ? '0.00' : span.toFixed(2);

    // Build human-friendly Span Description
    let spanDescription = "N/A";
    if (marker.isLineBreak && marker.startFromMarkerId && marker.spanLength > 0) {
      const startMarkerIdx = markers.findIndex(m => m.id === marker.startFromMarkerId);
      spanDescription = `${(markerConfig[markers[startMarkerIdx].type] || {}).label} #${startMarkerIdx + 1} --> ${typeLabel} #${idx + 1}`;
    } else if (idx > 0 && marker.spanLength && !marker.isLineBreak) {
      spanDescription = `${(markerConfig[markers[idx - 1].type] || {}).label} #${idx} --> ${typeLabel} #${idx + 1}`;
    }

    const row = [
      siteName,
      surveyTypeLabel, // ADDED SURVEY TYPE
      spanDescription,
      markerNumber,
      typeLabel,
      lineMainTypeLabel,
      lineSubtypeLabel,
      conductorTypeLabel,
      lat,
      lng,
      spanText,
      connectedFrom,
      cumulativeDistance.toFixed(2),
      isLineBreak
    ].map(item => `"${item}"`).join(',');

    csvContent += row + "\n";
  });

  const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = `${siteName.replace(/[^a-z0-9]/gi, '_')}-data-v3-8-dynamic-${Date.now()}.csv`;
  a.click();
  URL.revokeObjectURL(url);
  alert('Data exported successfully as CSV/Excel!');
}

// Initializations
document.addEventListener('DOMContentLoaded', () => {
    // Set default survey type
    const defaultSurveyInput = document.querySelector('input[name="surveyType"][checked]');
    if (defaultSurveyInput) {
        selectedSurveyType = defaultSurveyInput.value;
    }

    // Select the default line type
    const defaultLineInput = document.querySelector('input[name="lineType"][checked]');
    if (defaultLineInput) {
        selectedLineSubtype = defaultLineInput.value;
        selectedLineMainType = defaultLineInput.getAttribute('data-main-type');
    }
    
    populateConductorType();
    updateMarkerSelectors();
    initLeafletMap();
});
</script>

</body>
</html>
