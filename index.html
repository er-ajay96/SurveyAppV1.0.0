<!DOCTYPE html>

<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>Electrical Line Survey V3.7</title>

<link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />

<style>
* {
margin: 0;
padding: 0;
box-sizing: border-box;
}

body {
font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
background: linear-gradient(135deg, #e0f2fe 0%, #ddd6fe 100%);
min-height: 100vh;
padding: 16px;
padding-bottom: 60px;
}

.container {
max-width: 1200px;
margin: 0 auto;
}

.card {
background: white;
border-radius: 16px;
box-shadow: 0 10px 30px rgba(0,0,0,0.1);
padding: 24px;
margin-bottom: 24px;
}

.header {
display: flex;
justify-content: space-between;
align-items: center;
margin-bottom: 20px;
flex-wrap: wrap;
gap: 16px;
}

.header-left {
display: flex;
align-items: center;
gap: 16px;
}

.icon-box {
background: #3b82f6;
padding: 12px;
border-radius: 12px;
color: white;
font-size: 28px;
}

.title-section h1 {
font-size: 24px;
color: #1f2937;
margin-bottom: 4px;
}

.title-section p {
font-size: 14px;
color: #6b7280;
}

.distance-display {
text-align: right;
}

.distance-value {
font-size: 32px;
font-weight: bold;
color: #3b82f6;
}

.distance-label {
font-size: 14px;
color: #6b7280;
}

.stats-grid {
display: grid;
grid-template-columns: repeat(3, 1fr);
gap: 16px;
margin-top: 20px;
}

.stat-card {
padding: 16px;
border-radius: 12px;
}

.stat-card.blue { background: #eff6ff; }
.stat-card.green { background: #f0fdf4; }
.stat-card.purple { background: #faf5ff; }

.stat-label {
font-size: 14px;
color: #6b7280;
margin-bottom: 4px;
}

.stat-value {
font-size: 24px;
font-weight: bold;
}

.stat-value.blue { color: #3b82f6; }
.stat-value.green { color: #10b981; }
.stat-value.purple { color: #a855f7; }

.btn {
padding: 12px 24px;
border: none;
border-radius: 12px;
font-size: 16px;
font-weight: 600;
cursor: pointer;
display: flex;
align-items: center;
justify-content: center;
gap: 8px;
transition: all 0.2s;
width: 100%;
}

.btn:disabled {
background: #d1d5db !important;
color: #9ca3af !important;
cursor: not-allowed;
}

.btn-green {
background: #10b981;
color: white;
}

.btn-green:hover:not(:disabled) {
background: #059669;
}

.btn-red {
background: #ef4444;
color: white;
}

.btn-red:hover:not(:disabled) {
background: #dc2626;
}

.btn-blue {
background: #3b82f6;
color: white;
}

.btn-blue:hover:not(:disabled) {
background: #2563eb;
}

.btn-purple {
background: #a855f7;
color: white;
}

.btn-purple:hover:not(:disabled) {
background: #9333ea;
}

.marker-types {
display: grid;
grid-template-columns: repeat(4, 1fr);
gap: 12px;
margin: 16px 0;
}

.pole-type-selection {
margin-top: 12px;
display: grid;
grid-template-columns: repeat(2, 1fr);
gap: 8px;
}

.pole-type-selection label {
display: flex;
align-items: center;
padding: 8px;
border: 1px solid #d1d5db;
border-radius: 8px;
font-size: 14px;
cursor: pointer;
transition: background-color 0.2s;
}

.pole-type-selection input[type="radio"] {
margin-right: 8px;
accent-color: #3b82f6;
}

.pole-type-selection label:hover {
background-color: #f3f4f6;
}

.marker-btn {
padding: 16px;
border: none;
border-radius: 12px;
background: #f3f4f6;
cursor: pointer;
transition: all 0.2s;
font-weight: 600;
}

.marker-btn:hover {
background: #e5e7eb;
}

.marker-btn.active {
background: #3b82f6;
color: white;
}

.marker-icon {
font-size: 32px;
margin-bottom: 8px;
}

.marker-label {
font-size: 14px;
}

.button-grid {
display: grid;
grid-template-columns: repeat(2, 1fr);
gap: 12px;
}

canvas {
width: 100%;
border: 2px solid #e5e7eb;
border-radius: 12px;
}

.markers-list {
max-height: 300px;
overflow-y: auto;
}

.marker-item {
display: flex;
align-items: center;
justify-content: space-between;
background: #f9fafb;
padding: 12px;
border-radius: 12px;
margin-bottom: 8px;
}

.marker-info {
display: flex;
align-items: center;
gap: 12px;
}

.marker-item-icon {
font-size: 24px;
}

.marker-details h4 {
font-size: 16px;
color: #1f2937;
margin-bottom: 4px;
}

.marker-coords {
font-size: 12px;
color: #6b7280;
}

.span-length {
font-size: 12px;
font-weight: bold;
color: #3b82f6;
margin-left: 8px;
}

.delete-btn {
background: #fee2e2;
color: #ef4444;
border: none;
padding: 8px;
border-radius: 8px;
cursor: pointer;
transition: all 0.2s;
}

.delete-btn:hover {
background: #fecaca;
}

h2 {
font-size: 18px;
color: #1f2937;
margin-bottom: 16px;
}

input[type="file"] {
display: none;
}

label.btn {
cursor: pointer;
}

.text-input-group {
margin-bottom: 20px;
}

.text-input-group label {
display: block; 
font-weight: 600; 
margin-bottom: 8px; 
color: #374151;
}

.text-input-group input {
width: 100%; 
padding: 12px; 
border: 1px solid #d1d5db; 
border-radius: 8px; 
font-size: 16px;
}

.footer-info {
text-align: center;
padding: 20px 0;
font-size: 12px;
color: #6b7280;
margin-top: 24px;
border-top: 1px solid #e5e7eb;
}
.footer-info p {
margin: 4px 0;
}

#leafletMap {
height: 500px; 
width: 100%;
border: 2px solid #e5e7eb;
border-radius: 12px;
}

@media (max-width: 768px) {
.stats-grid {
grid-template-columns: 1fr;
}

.marker-types {
grid-template-columns: repeat(2, 1fr);
}
.pole-type-selection {
grid-template-columns: 1fr;
}

.button-grid {
grid-template-columns: 1fr;
}

.header {
flex-direction: column;
text-align: center;
}

.distance-display {
text-align: center;
}
}
</style>

</head>
<body>
<div class="container">
<div class="card">
<div style="text-align: right; margin-bottom: 10px;">
<a href="https://drive.google.com/file/d/1AtU_U-QRIqjK1npsIydHofihzbMXOD5J/view?usp=drivesdk" target="_blank" style="color: #3b82f6; text-decoration: none; font-weight: 600; font-size: 14px;">
üìñ User Manual
</a>
</div>
<div class="header">
<div class="header-left">
<div class="icon-box">‚ö°</div>
<div class="title-section">
<h1>Electrical Line Survey V3.7</h1>
<p>GPS-based line tracking & mapping</p>
</div>
</div>
<div class="distance-display">
<div class="distance-value" id="totalDistance">0.0m</div>
<div class="distance-label">Total Distance (Straight Line)</div>
</div>
</div>

<div class="stats-grid">
<div class="stat-card blue">
<div class="stat-label">Points</div>
<div class="stat-value blue" id="pointsCount">0</div>
</div>
<div class="stat-card green">
<div class="stat-label">Markers</div>
<div class="stat-value green" id="markersCount">0</div>
</div>
<div class="stat-card purple">
<div class="stat-label">Accuracy</div>
<div class="stat-value purple" id="accuracy">--</div>
</div>
</div>
</div>

<div class="card">
<h2>Controls</h2>

<div class="text-input-group">
<label for="siteNameInput">Site Name</label>
<input type="text" id="siteNameInput" value="New Survey Site" oninput="updateSiteName(this.value)">
</div>

<button class="btn btn-green" id="startBtn" onclick="startTracking()">
‚ñ∂ Start Tracking
</button>
<button class="btn btn-red" id="stopBtn" onclick="stopTracking()" style="display:none;">
‚èπ Stop Tracking
</button>
<div id="gpsStatus" style="margin-top: 10px; color: #f97316; font-weight: 600;"></div> 

<div style="margin-top: 20px;">
<label style="display: block; font-weight: 600; margin-bottom: 12px; color: #374151;">Select Marker Type</label>
<div class="marker-types">
<button class="marker-btn active" onclick="selectMarkerType('pole')">
<div class="marker-icon">üíà</div>
<div class="marker-label">Pole</div>
</button>
<button class="marker-btn" onclick="selectMarkerType('dtr')">
<div class="marker-icon">üü•</div>
<div class="marker-label">DTR</div>
</button>
<button class="marker-btn" onclick="selectMarkerType('structure')">
<div class="marker-icon">‚≠ï</div>
<div class="marker-label">Structure</div>
</button>
<button class="marker-btn" onclick="selectMarkerType('other')">
<div class="marker-icon">‚ùì</div>
<div class="marker-label">Other</div>
</button>
</div>

<div id="poleTypeContainer">
<label style="display: block; font-weight: 600; margin-top: 12px; margin-bottom: 8px; color: #374151;">Select Pole Type (Required for Span Color)</label>
<div class="pole-type-selection" onchange="updateSelectedPoleType(event)">
<label><input type="radio" name="poleType" value="HT" checked> HT (High Tension)</label>
<label><input type="radio" name="poleType" value="LT-1P"> LT 1-phase</label>
<label><input type="radio" name="poleType" value="LT-2P"> LT 2-phase</label>
<label><input type="radio" name="poleType" value="LT-3P"> LT 3-phase</label>
</div>
</div>

</div>

<button class="btn btn-blue" id="addMarkerBtn" onclick="addMarker()" disabled style="margin-top: 16px;">
üìç Add <span id="markerTypeLabel">Pole</span> at Current Location
</button>

</div>

<div class="card">
<h2>Survey Map (Schematic View)</h2>
<canvas id="mapCanvas" width="800" height="500"></canvas>
</div>

<div class="card">
<h2>Interactive Map View (Leaflet/OSM)</h2>
<div id="leafletMap"></div>
</div>
<div class="card">
<h2>Actions</h2>
<div class="button-grid">
<button class="btn btn-green" onclick="saveToJSON()">
üíæ Save JSON
</button>
<label class="btn btn-blue">
üì§ Load JSON
<input type="file" accept=".json" onchange="loadFromJSON(event)">
</label>
<button class="btn btn-purple" onclick="exportToPNG()">
üìÑ Export PNG
</button>
<button class="btn btn-blue" onclick="exportToCSV()">
üìä Export CSV
</button>
<button class="btn btn-red" onclick="clearAll()">
üóëÔ∏è Clear All
</button>
</div>
</div>

<div class="card" id="markersListCard" style="display:none;">
<h2>Marked Locations</h2>
<div class="markers-list" id="markersList"></div>
</div>

</div> 
<div class="footer-info">
<p>Electrical Line Survey App | Version 3.7</p>
<p>Developed for Professional Field Use | For Support: +91-70187-56182/ErAjay.HPSEB@gmail.com</p>
<p>¬© 2025‚Äì26 ErAjay Kumar . All rights reserved.</p>
</div>

<script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>

<script>
// State
let isTracking = false;
let isManualPosition = false;
let linePoints = [];
let markers = [];
let totalDistance = 0;
let currentPosition = null;
let siteName = document.getElementById('siteNameInput').value;
let selectedMarkerType = 'pole';
let selectedPoleType = 'HT';
let accuracy = null;
let watchId = null;
let startFromMarkerIndex = null;
let startFromMarkerPosition = null;

// Leaflet Map State
let leafletMapInstance = null;
let leafletMarkers = [];
let leafletPolylines = [];
let mapTiles = null;
let satelliteTiles = null;

// GPS FILTERS
const MIN_MOVEMENT_DISTANCE = 2.0;
const MAX_ACCURACY_ERROR = 10.0;
const ACCURACY_THRESHOLD = 10.0;
const INITIAL_FIX_TIMEOUT = 30000;
let initialFixAttempt = false;
let initialFixTimeoutId = null;

const markerTypes = {
pole: { label: 'Pole', icon: 'üíà', color: '#3b82f6' },
dtr: { label: 'DTR', icon: 'üü•', color: '#ef4444' },
structure: { label: 'Structure', icon: '‚≠ï', color: '#f59e0b' },
other: { label: 'Other', icon: '‚ùì', color: '#6b7280' } 
};

const poleTypes = {
'HT': { label: 'HT (High Tension)', color: '#dc2626' },
'LT-1P': { label: 'LT 1-phase', color: '#2563eb' },
'LT-2P': { label: 'LT 2-phase', color: '#059669' },
'LT-3P': { label: 'LT 3-phase', color: '#f59e0b' }
};

const gpsStatusElement = document.getElementById('gpsStatus');
const poleTypeContainer = document.getElementById('poleTypeContainer');

function calculateDistance(lat1, lon1, lat2, lon2) {
const R = 6371e3;
const œÜ1 = lat1 * Math.PI / 180;
const œÜ2 = lat2 * Math.PI / 180;
const ŒîœÜ = (lat2 - lat1) * Math.PI / 180;
const ŒîŒª = (lon2 - lon1) * Math.PI / 180;

const a = Math.sin(ŒîœÜ / 2) * Math.sin(ŒîœÜ / 2) +
Math.cos(œÜ1) * Math.cos(œÜ2) *
Math.sin(ŒîŒª / 2) * Math.sin(ŒîŒª / 2);
const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));

return R * c;
}

function updateTotalDistance() {
totalDistance = 0;
if (markers.length >= 2) {
for (let i = 1; i < markers.length; i++) {
if (!markers[i].isLineBreak) {
const dist = calculateDistance(
markers[i-1].lat, markers[i-1].lng,
markers[i].lat, markers[i].lng
);
markers[i].spanLength = dist;
totalDistance += dist;
} else if (markers[i].startFromMarkerId) {
if (markers[i].spanLength > 0) {
totalDistance += markers[i].spanLength;
}
} else {
markers[i].spanLength = 0;
}
}
markers[0].spanLength = 0;
} else if (markers.length === 1) {
markers[0].spanLength = 0;
}
}

function updateSiteName(name) {
siteName = name;
drawMap();
updateUI(); 
}

function startTracking() {
if (!navigator.geolocation) {
alert('Geolocation is not supported by your browser');
return;
}

isTracking = true;
isManualPosition = false;
startFromMarkerIndex = null;
startFromMarkerPosition = null;
initialFixAttempt = true;
document.getElementById('startBtn').style.display = 'none';
document.getElementById('stopBtn').style.display = 'flex';
document.getElementById('addMarkerBtn').disabled = true;

gpsStatusElement.textContent = 'Searching for high-accuracy GPS fix...';
gpsStatusElement.style.color = '#f97316';

initialFixTimeoutId = setTimeout(() => {
if (initialFixAttempt) {
gpsStatusElement.textContent = 'Warning: Low accuracy after 30 seconds. Proceeding with current accuracy.';
gpsStatusElement.style.color = '#dc2626';
document.getElementById('addMarkerBtn').disabled = false;
initialFixAttempt = false; 
}
}, INITIAL_FIX_TIMEOUT);

watchId = navigator.geolocation.watchPosition(
(position) => {
accuracy = position.coords.accuracy;

if (initialFixAttempt) {
if (accuracy <= ACCURACY_THRESHOLD) {
clearTimeout(initialFixTimeoutId);
initialFixAttempt = false;
document.getElementById('addMarkerBtn').disabled = false;
gpsStatusElement.textContent = `GPS Fix Achieved: ¬±${accuracy.toFixed(1)}m`;
gpsStatusElement.style.color = '#10b981';
} else {
gpsStatusElement.textContent = `Searching for high-accuracy GPS fix... (Current: ¬±${accuracy.toFixed(1)}m)`;
updateUI(); 
return; 
}
}

if (accuracy > MAX_ACCURACY_ERROR) {
console.warn('Point skipped due to poor accuracy:', accuracy.toFixed(1) + 'm');
updateUI();
return; 
}

const newPoint = {
lat: position.coords.latitude,
lng: position.coords.longitude,
timestamp: Date.now()
};

if (linePoints.length > 0) {
const lastPoint = linePoints[linePoints.length - 1];
const distanceMoved = calculateDistance(
lastPoint.lat, lastPoint.lng,
newPoint.lat, newPoint.lng
);

if (distanceMoved < MIN_MOVEMENT_DISTANCE) {
currentPosition = newPoint;
updateUI(); 
return; 
}
}

currentPosition = newPoint;
linePoints.push(newPoint); 

updateTotalDistance(); 

updateUI();
drawMap(); 
drawLeafletMap(); 
},
(error) => {
console.error('Error getting location:', error);
gpsStatusElement.textContent = `GPS Error: ${error.message}`;
gpsStatusElement.style.color = '#dc2626';
alert('Error getting location. Please enable GPS.');
stopTracking(); 
},
{
enableHighAccuracy: true,
timeout: 5000,
maximumAge: 0
}
);
}

function stopTracking() {
if (watchId) {
navigator.geolocation.clearWatch(watchId);
watchId = null;
}
clearTimeout(initialFixTimeoutId);
initialFixAttempt = false;
isTracking = false;
isManualPosition = false;
startFromMarkerIndex = null;
startFromMarkerPosition = null;
document.getElementById('startBtn').style.display = 'flex';
document.getElementById('stopBtn').style.display = 'none';
document.getElementById('addMarkerBtn').disabled = true;
gpsStatusElement.textContent = 'Tracking stopped.';
gpsStatusElement.style.color = '#6b7280';
}

function selectMarkerType(type) {
selectedMarkerType = type;
document.querySelectorAll('.marker-btn').forEach(btn => {
btn.classList.remove('active');
});
event.target.closest('.marker-btn').classList.add('active');
document.getElementById('markerTypeLabel').textContent = markerTypes[type].label;

poleTypeContainer.style.display = (type === 'pole' || type === 'dtr') ? 'block' : 'none';
}

function updateSelectedPoleType(event) {
if (event.target.name === 'poleType') {
selectedPoleType = event.target.value;
}
}

function startFromMarker(id) {
const markerIndex = markers.findIndex(m => m.id == id);
if (markerIndex === -1) return;

const marker = markers[markerIndex];

startFromMarkerIndex = markerIndex;
startFromMarkerPosition = {
lat: marker.lat,
lng: marker.lng
};

if (!isTracking) {
isTracking = true;
initialFixAttempt = false;
document.getElementById('startBtn').style.display = 'none';
document.getElementById('stopBtn').style.display = 'flex';
document.getElementById('addMarkerBtn').disabled = false;

gpsStatusElement.textContent = 'Starting GPS tracking...';
gpsStatusElement.style.color = '#f97316';

watchId = navigator.geolocation.watchPosition(
(position) => {
accuracy = position.coords.accuracy;

if (accuracy > MAX_ACCURACY_ERROR) {
console.warn('Point skipped due to poor accuracy:', accuracy.toFixed(1) + 'm');
updateUI();
return; 
}

const newPoint = {
lat: position.coords.latitude,
lng: position.coords.longitude,
timestamp: Date.now()
};

if (linePoints.length > 0) {
const lastPoint = linePoints[linePoints.length - 1];
const distanceMoved = calculateDistance(
lastPoint.lat, lastPoint.lng,
newPoint.lat, newPoint.lng
);

if (distanceMoved < MIN_MOVEMENT_DISTANCE) {
currentPosition = newPoint;
updateUI(); 
return; 
}
}

currentPosition = newPoint;
linePoints.push(newPoint); 

updateUI();
drawMap(); 
drawLeafletMap(); 

gpsStatusElement.textContent = `Starting from Marker #${markerIndex + 1}. Current accuracy: ¬±${accuracy.toFixed(1)}m. Move to your new location and click "Add Pole".`;
gpsStatusElement.style.color = '#a855f7';
},
(error) => {
console.error('Error getting location:', error);
gpsStatusElement.textContent = `GPS Error: ${error.message}`;
gpsStatusElement.style.color = '#dc2626';
},
{
enableHighAccuracy: true,
timeout: 5000,
maximumAge: 0
}
);
} else {
gpsStatusElement.textContent = `Starting from Marker #${markerIndex + 1}. Move to your new location and click "Add Pole".`;
gpsStatusElement.style.color = '#a855f7';
}

updateMarkersList();
drawMap();
drawLeafletMap();
}

function addMarker() {
if (!currentPosition && !startFromMarkerPosition) {
alert('Waiting for GPS position...');
return;
}

const positionToUse = currentPosition || startFromMarkerPosition;

if (!positionToUse) {
alert('No position available. Please wait for GPS.');
return;
}

const newMarker = {
id: Date.now(),
type: selectedMarkerType,
poleType: (selectedMarkerType === 'pole' || selectedMarkerType === 'dtr') ? selectedPoleType : null,
lat: positionToUse.lat,
lng: positionToUse.lng,
timestamp: Date.now(),
spanLength: 0,
isLineBreak: false,
startFromMarkerId: null // Initialize explicitly
};

// If we're starting from an existing marker
if (startFromMarkerIndex !== null && startFromMarkerPosition) {
newMarker.isLineBreak = true;

const spanDistance = calculateDistance(
startFromMarkerPosition.lat,
startFromMarkerPosition.lng,
newMarker.lat,
newMarker.lng
);
newMarker.spanLength = spanDistance;
newMarker.startFromMarkerId = markers[startFromMarkerIndex].id;

console.log('Jump span created:', {
fromMarker: startFromMarkerIndex + 1,
toNewMarker: markers.length + 1,
distance: spanDistance.toFixed(2),
startFromMarkerId: newMarker.startFromMarkerId
});

// Clear the "start from" state
startFromMarkerIndex = null;
startFromMarkerPosition = null;
}

markers.push(newMarker);
updateTotalDistance(); 
updateUI();
drawMap();
drawLeafletMap();
updateMarkersList();

gpsStatusElement.textContent = 'Marker added successfully.';
gpsStatusElement.style.color = '#10b981';

if (isManualPosition) {
isManualPosition = false;
currentPosition = null;
document.getElementById('addMarkerBtn').disabled = true;
drawMap(); 
drawLeafletMap();
}
}

function clearAll() {
if (confirm('Clear all data? This cannot be undone.')) {
stopTracking();
linePoints = [];
markers = [];
totalDistance = 0;
currentPosition = null;
startFromMarkerIndex = null;
startFromMarkerPosition = null;
siteName = 'New Survey Site'; 
document.getElementById('siteNameInput').value = siteName;
updateUI();
drawMap();
drawLeafletMap(); 
updateMarkersList();
gpsStatusElement.textContent = '';
}
}

function updateUI() {
document.getElementById('totalDistance').textContent = totalDistance.toFixed(1) + 'm';
document.getElementById('pointsCount').textContent = linePoints.length;
document.getElementById('markersCount').textContent = markers.length;
document.getElementById('accuracy').textContent = accuracy ? `¬±${accuracy.toFixed(1)}m` : '--';

if (currentPosition || startFromMarkerPosition) {
document.getElementById('addMarkerBtn').disabled = false;
}

drawLeafletMap();
}

function updateMarkersList() {
const listCard = document.getElementById('markersListCard');
const list = document.getElementById('markersList');

if (markers.length === 0) {
listCard.style.display = 'none';
return;
}

listCard.style.display = 'block';
list.innerHTML = '';

markers.forEach((marker, idx) => {
const type = markerTypes[marker.type];
const poleTypeInfo = marker.poleType ? `(${poleTypes[marker.poleType].label})` : '';

let spanText = '';
if (marker.isLineBreak && marker.startFromMarkerId && marker.spanLength > 0) {
const startMarkerIdx = markers.findIndex(m => m.id === marker.startFromMarkerId);
spanText = `<span class="span-length" style="color:#a855f7;">Jump Span: ${marker.spanLength.toFixed(0)}m from #${startMarkerIdx + 1}</span>`;
} else if (idx > 0 && marker.spanLength && !marker.isLineBreak) {
spanText = `<span class="span-length">${marker.spanLength.toFixed(0)}m Span</span>`;
} else if (marker.isLineBreak && !marker.startFromMarkerId) {
spanText = '<span class="span-length" style="color:#dc2626;">New Segment Start (No Connection)</span>';
}

const item = document.createElement('div');
item.className = 'marker-item';

const startBtn = `<button class="btn btn-purple" style="padding: 5px 10px; font-size: 12px; height: 32px; margin-right: 8px; width: auto;" onclick="startFromMarker(${marker.id})">Start From Here</button>`;

item.innerHTML = `
<div class="marker-info">
<div class="marker-item-icon">${type.icon}</div>
<div class="marker-details">
<h4>${type.label} #${idx + 1} ${poleTypeInfo} ${spanText}</h4>
<div class="marker-coords">${marker.lat.toFixed(6)}, ${marker.lng.toFixed(6)}</div>
</div>
</div>
<div style="display:flex; align-items:center;">
${startBtn}
<button class="delete-btn" onclick="deleteMarker(${marker.id})">üóëÔ∏è</button>
</div>
`;
list.appendChild(item);
});
}

function deleteMarker(id) {
markers = markers.filter(m => m.id !== id);
updateTotalDistance(); 
updateUI();
drawMap();
drawLeafletMap();
updateMarkersList();
}

function offsetLatLng(lat, lng, dx, dy) {
const R = 6371e3;
const newLat = lat + (dy / R) * (180 / Math.PI);
const newLng = lng + (dx / (R * Math.cos(lat * Math.PI / 180))) * (180 / Math.PI);
return { lat: newLat, lng: newLng };
}

function drawMap() {
const canvas = document.getElementById('mapCanvas');
const ctx = canvas.getContext('2d');
const width = canvas.width;
const height = canvas.height;
const GRID_SIZE = 10; 

ctx.fillStyle = '#f0f9ff';
ctx.fillRect(0, 0, width, height);

ctx.fillStyle = '#1f2937';
ctx.font = 'bold 18px Arial';
ctx.textAlign = 'left';
ctx.fillText(`Site: ${siteName}`, 10, 25);

const pointsForBounds = [...markers, ...linePoints];

if (currentPosition && isManualPosition) {
pointsForBounds.push(currentPosition);
}

if (startFromMarkerPosition) {
pointsForBounds.push(startFromMarkerPosition);
}

if (pointsForBounds.length === 0) {
ctx.fillStyle = '#64748b';
ctx.font = '16px Arial';
ctx.textAlign = 'center';
ctx.fillText('Start tracking or add markers to see map', width / 2, height / 2);
return;
}

const lats = pointsForBounds.map(p => p.lat);
const lngs = pointsForBounds.map(p => p.lng);
const minLat = Math.min(...lats);
const maxLat = Math.max(...lats);
const minLng = Math.min(...lngs);
const maxLng = Math.max(...lngs);

const padding = 40;
const latRange = maxLat - minLat || 0.001;
const lngRange = maxLng - minLng || 0.001;

const scaleX = (width - 2 * padding) / lngRange;
const scaleY = (height - 2 * padding) / latRange;
const scale = Math.min(scaleX, scaleY);

const toX = (lng) => padding + (lng - minLng) * scale;
const toY = (lat) => height - padding - (lat - minLat) * scale;

if (minLat && minLng) {
const origin = { lat: minLat, lng: minLng };
const offsetN = offsetLatLng(origin.lat, origin.lng, 0, GRID_SIZE);
const offsetE = offsetLatLng(origin.lat, origin.lng, GRID_SIZE, 0);
const latStep = offsetN.lat - origin.lat;
const lngStep = offsetE.lng - origin.lng;

ctx.strokeStyle = 'rgba(150, 150, 150, 0.5)';
ctx.lineWidth = 0.5;

let currentLat = minLat - (latRange/10); 
while (currentLat <= maxLat + (latRange/10)) {
ctx.beginPath();
const y = toY(currentLat);
ctx.moveTo(0, y);
ctx.lineTo(width, y);
ctx.stroke();
currentLat += latStep;
}

let currentLng = minLng - (lngRange/10); 
while (currentLng <= maxLng + (lngRange/10)) {
ctx.beginPath();
const x = toX(currentLng);
ctx.moveTo(x, 0);
ctx.lineTo(x, height);
ctx.stroke();
currentLng += lngStep;
}

ctx.fillStyle = 'rgba(100, 100, 100, 0.8)';
ctx.font = '10px Arial';
ctx.textAlign = 'right';
ctx.fillText(`Grid: ${GRID_SIZE}m x ${GRID_SIZE}m`, width - 10, height - 10);
}

if (linePoints.length > 1) {
ctx.strokeStyle = '#d1d5db'; 
ctx.lineWidth = 1;
ctx.beginPath();
ctx.moveTo(toX(linePoints[0].lng), toY(linePoints[0].lat));
for (let i = 1; i < linePoints.length; i++) {
ctx.lineTo(toX(linePoints[i].lng), toY(linePoints[i].lat));
}
ctx.stroke();
}

if (markers.length > 1) {
for (let i = 1; i < markers.length; i++) {
const prevMarker = markers[i - 1];
const currentMarker = markers[i];

if (currentMarker.isLineBreak) {
if (currentMarker.startFromMarkerId) {
const startMarker = markers.find(m => m.id === currentMarker.startFromMarkerId);
if (startMarker) {
let spanColor = '#3b82f6';
if (currentMarker.type === 'pole' || currentMarker.type === 'dtr') {
spanColor = poleTypes[currentMarker.poleType] ? poleTypes[currentMarker.poleType].color : '#3b82f6';
}

ctx.strokeStyle = spanColor; 
ctx.lineWidth = 3;
ctx.setLineDash([10, 5]);
ctx.beginPath();
ctx.moveTo(toX(startMarker.lng), toY(startMarker.lat));
ctx.lineTo(toX(currentMarker.lng), toY(currentMarker.lat));
ctx.stroke();
ctx.setLineDash([]);
}
}
continue; 
}

let spanColor = '#3b82f6';
if (currentMarker.type === 'pole' || currentMarker.type === 'dtr') {
spanColor = poleTypes[currentMarker.poleType] ? poleTypes[currentMarker.poleType].color : '#3b82f6';
}

ctx.strokeStyle = spanColor; 
ctx.lineWidth = 3;
ctx.beginPath();
ctx.moveTo(toX(prevMarker.lng), toY(prevMarker.lat));
ctx.lineTo(toX(currentMarker.lng), toY(currentMarker.lat));
ctx.stroke();
}
}

if (startFromMarkerPosition && currentPosition) {
ctx.strokeStyle = '#a855f7';
ctx.lineWidth = 2;
ctx.setLineDash([5, 5]);
ctx.beginPath();
ctx.moveTo(toX(startFromMarkerPosition.lng), toY(startFromMarkerPosition.lat));
ctx.lineTo(toX(currentPosition.lng), toY(currentPosition.lat));
ctx.stroke();
ctx.setLineDash([]);

const dist = calculateDistance(
startFromMarkerPosition.lat, startFromMarkerPosition.lng,
currentPosition.lat, currentPosition.lng
);
const midX = (toX(startFromMarkerPosition.lng) + toX(currentPosition.lng)) / 2;
const midY = (toY(startFromMarkerPosition.lat) + toY(currentPosition.lat)) / 2;

ctx.fillStyle = '#ffffff';
ctx.fillRect(midX - 30, midY - 10, 60, 20);

ctx.fillStyle = '#a855f7';
ctx.font = 'bold 12px Arial';
ctx.textAlign = 'center';
ctx.textBaseline = 'middle';
ctx.fillText(`${dist.toFixed(0)}m`, midX, midY);
}

markers.forEach((marker, idx) => {
const type = markerTypes[marker.type];
const x = toX(marker.lng);
const y = toY(marker.lat);
const markerNumber = idx + 1;

let markerColor = type.color;
if (marker.type === 'pole' || marker.type === 'dtr') {
markerColor = poleTypes[marker.poleType] ? poleTypes[marker.poleType].color : type.color;
}

ctx.strokeStyle = markerColor;
ctx.lineWidth = 2;
ctx.beginPath();
ctx.arc(x, y, 15, 0, Math.PI * 2);
ctx.stroke();

ctx.font = '24px Arial';
ctx.textAlign = 'center';
ctx.textBaseline = 'middle';
ctx.fillText(type.icon, x, y);

ctx.fillStyle = '#1f2937';
ctx.font = 'bold 12px Arial';
ctx.textAlign = 'left';
ctx.textBaseline = 'top';
ctx.fillText(markerNumber, x + 18, y - 10);

if (idx > 0 && marker.spanLength > 0 && !marker.isLineBreak) {
const prevMarker = markers[idx - 1];
const prevX = toX(prevMarker.lng);
const prevY = toY(prevMarker.lat);
const midX = (x + prevX) / 2;
const midY = (y + prevY) / 2;

let spanColor = '#3b82f6'; 
if (marker.type === 'pole' || marker.type === 'dtr') {
spanColor = poleTypes[marker.poleType] ? poleTypes[marker.poleType].color : '#3b82f6';
}

ctx.fillStyle = '#ffffff';
ctx.fillRect(midX - 25, midY - 10, 50, 20); 

ctx.fillStyle = spanColor;
ctx.font = 'bold 12px Arial';
ctx.textAlign = 'center';
ctx.textBaseline = 'middle';
ctx.fillText(`${marker.spanLength.toFixed(0)}m`, midX, midY);
} else if (marker.isLineBreak && marker.startFromMarkerId && marker.spanLength > 0) {
const startMarker = markers.find(m => m.id === marker.startFromMarkerId);
if (startMarker) {
const startX = toX(startMarker.lng);
const startY = toY(startMarker.lat);
const midX = (x + startX) / 2;
const midY = (y + startY) / 2;

let spanColor = '#3b82f6';
if (marker.type === 'pole' || marker.type === 'dtr') {
spanColor = poleTypes[marker.poleType] ? poleTypes[marker.poleType].color : '#3b82f6';
}

ctx.fillStyle = '#ffffff';
ctx.fillRect(midX - 25, midY - 10, 50, 20);

ctx.fillStyle = spanColor;
ctx.font = 'bold 12px Arial';
ctx.textAlign = 'center';
ctx.textBaseline = 'middle';
ctx.fillText(`${marker.spanLength.toFixed(0)}m`, midX, midY);
}
}
});

if (currentPosition) {
const x = toX(currentPosition.lng);
const y = toY(currentPosition.lat);

if (isManualPosition) {
ctx.fillStyle = '#a855f7';
ctx.strokeStyle = '#ffffff';
ctx.lineWidth = 3;
ctx.beginPath();
ctx.arc(x, y, 10, 0, Math.PI * 2);
ctx.fill();
ctx.stroke();

ctx.fillStyle = '#ffffff';
ctx.font = 'bold 12px Arial';
ctx.fillText('START', x, y + 1);
} else {
ctx.fillStyle = '#10b981';
ctx.beginPath();
ctx.arc(x, y, 8, 0, Math.PI * 2);
ctx.fill();

ctx.strokeStyle = '#ffffff';
ctx.lineWidth = 2;
ctx.stroke();
}
}
}

function initLeafletMap() {
let centerLat = 31.7831; 
let centerLng = 76.9926; 
if (markers.length > 0) {
centerLat = markers[0].lat;
centerLng = markers[0].lng;
} else if (currentPosition) {
centerLat = currentPosition.lat;
centerLng = currentPosition.lng;
}

if (leafletMapInstance) {
leafletMapInstance.remove();
}

leafletMapInstance = L.map('leafletMap').setView([centerLat, centerLng], 15);

satelliteTiles = L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', {
attribution: 'Tiles &copy; Esri'
}).addTo(leafletMapInstance);

mapTiles = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
attribution: '&copy; OpenStreetMap contributors'
});

const baseMaps = {
"Satellite View": satelliteTiles,
"Street Map": mapTiles
};
L.control.layers(baseMaps).addTo(leafletMapInstance);

drawLeafletMap();
}

function drawLeafletMap() {
if (!leafletMapInstance) {
initLeafletMap();
return;
}

leafletMarkers.forEach(m => m.remove());
leafletMarkers = [];
leafletPolylines.forEach(p => p.remove());
leafletPolylines = [];

let segmentCoordinates = [];
let currentSegmentColor = '#3b82f6';

for (let i = 0; i < markers.length; i++) {
const marker = markers[i];

if (i > 0) {
const prevMarker = markers[i - 1];

if (!marker.isLineBreak) {
segmentCoordinates.push([marker.lat, marker.lng]);

let nextSegmentColor = '#3b82f6';
if (marker.type === 'pole' || marker.type === 'dtr') {
nextSegmentColor = poleTypes[marker.poleType] ? poleTypes[marker.poleType].color : '#3b82f6';
}

if (nextSegmentColor !== currentSegmentColor || i === markers.length - 1) {
const polyline = L.polyline(segmentCoordinates, {
color: currentSegmentColor, 
weight: 4,
opacity: 1.0,
dashArray: '8, 8'
}).addTo(leafletMapInstance);
leafletPolylines.push(polyline);

if (nextSegmentColor !== currentSegmentColor) {
segmentCoordinates = [[prevMarker.lat, prevMarker.lng], [marker.lat, marker.lng]];
currentSegmentColor = nextSegmentColor;
}
}
} else {
if (marker.startFromMarkerId) {
const startMarker = markers.find(m => m.id === marker.startFromMarkerId);
if (startMarker) {
let spanColor = '#3b82f6';
if (marker.type === 'pole' || marker.type === 'dtr') {
spanColor = poleTypes[marker.poleType] ? poleTypes[marker.poleType].color : '#3b82f6';
}
const jumpLine = L.polyline(
[[startMarker.lat, startMarker.lng], [marker.lat, marker.lng]],
{
color: spanColor,
weight: 4,
opacity: 1.0,
dashArray: '10, 10'
}
).addTo(leafletMapInstance);
leafletPolylines.push(jumpLine);
}
}

segmentCoordinates = [[marker.lat, marker.lng]];
if (marker.type === 'pole' || marker.type === 'dtr') {
currentSegmentColor = poleTypes[marker.poleType] ? poleTypes[marker.poleType].color : '#3b82f6';
} else {
currentSegmentColor = '#3b82f6';
}
}
} else {
segmentCoordinates.push([marker.lat, marker.lng]);
if (marker.type === 'pole' || marker.type === 'dtr') {
currentSegmentColor = poleTypes[marker.poleType] ? poleTypes[marker.poleType].color : '#3b82f6';
}
}

if (i === markers.length - 1 && segmentCoordinates.length > 1) {
const polyline = L.polyline(segmentCoordinates, {
color: currentSegmentColor,
weight: 4,
opacity: 1.0,
dashArray: '8, 8'
}).addTo(leafletMapInstance);
leafletPolylines.push(polyline);
}
}

if (startFromMarkerPosition && currentPosition) {
const previewLine = L.polyline(
[[startFromMarkerPosition.lat, startFromMarkerPosition.lng], 
[currentPosition.lat, currentPosition.lng]],
{
color: '#a855f7',
weight: 3,
opacity: 0.7,
dashArray: '5, 10'
}
).addTo(leafletMapInstance);
leafletPolylines.push(previewLine);
}

markers.forEach((marker, idx) => {
const type = markerTypes[marker.type];
const markerNumber = idx + 1;

let markerColor = type.color;
let poleTypeLabel = '';
if (marker.type === 'pole' || marker.type === 'dtr') {
markerColor = poleTypes[marker.poleType] ? poleTypes[marker.poleType].color : type.color;
poleTypeLabel = poleTypes[marker.poleType] ? ` - ${poleTypes[marker.poleType].label}` : '';
}

const spanText = (idx > 0 && marker.spanLength && !marker.isLineBreak) ? `${marker.spanLength.toFixed(0)}m Span` : (marker.isLineBreak && marker.spanLength > 0 ? `${marker.spanLength.toFixed(0)}m Span (Jump)` : marker.isLineBreak ? 'New Segment Start' : '');

const markerIcon = L.divIcon({
className: 'custom-marker',
html: `<div style="background-color: ${markerColor}; border: 3px solid white; color: white; border-radius: 50%; width: 30px; height: 30px; line-height: 25px; text-align: center; font-weight: bold; font-size: 14px;">${markerNumber}</div>`,
iconSize: [30, 30],
iconAnchor: [15, 15]
});

const lMarker = L.marker([marker.lat, marker.lng], {
icon: markerIcon,
title: `${type.label} #${markerNumber}`
}).addTo(leafletMapInstance);

lMarker.bindPopup(`
<div style="font-family: Arial; padding: 5px;">
<strong>${type.label} #${markerNumber}${poleTypeLabel}</strong><br>
Lat: ${marker.lat.toFixed(6)}, Lng: ${marker.lng.toFixed(6)}<br>
${spanText}
</div>
`);

leafletMarkers.push(lMarker);
});

if (currentPosition) {
let currentMarker;
if (isManualPosition) {
currentMarker = L.circleMarker([currentPosition.lat, currentPosition.lng], {
radius: 8,
color: '#a855f7',
fillColor: '#a855f7',
fillOpacity: 1,
weight: 3
}).bindPopup('Manual Start Location').addTo(leafletMapInstance);
} else {
currentMarker = L.circleMarker([currentPosition.lat, currentPosition.lng], {
radius: 5,
color: '#ffffff',
fillColor: '#10b981',
fillOpacity: 1,
weight: 2
}).bindPopup(`Live GPS: ¬±${accuracy.toFixed(1)}m`).addTo(leafletMapInstance);
}
leafletMarkers.push(currentMarker);
}

if (markers.length > 0) {
const allLatLngs = markers.map(m => [m.lat, m.lng]);
if (currentPosition) allLatLngs.push([currentPosition.lat, currentPosition.lng]);
if (startFromMarkerPosition) allLatLngs.push([startFromMarkerPosition.lat, startFromMarkerPosition.lng]);

if (allLatLngs.length > 1) {
leafletMapInstance.fitBounds(allLatLngs, { padding: [30, 30] });
} else if (allLatLngs.length === 1) {
leafletMapInstance.setView(allLatLngs[0], 17);
}
}
}

function saveToJSON() {
const data = {
version: '3.7',
created: new Date().toISOString(),
siteName: siteName, 
totalDistance: totalDistance, 
linePoints: linePoints,
markers: markers.map((m, idx) => ({
...m,
index: idx + 1,
typeLabel: markerTypes[m.type].label,
poleTypeLabel: m.poleType ? poleTypes[m.poleType].label : 'N/A',
spanLength: m.spanLength ? m.spanLength.toFixed(2) : 'N/A',
isLineBreak: m.isLineBreak || false
}))
};

const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
const url = URL.createObjectURL(blob);
const a = document.createElement('a');
a.href = url;
a.download = `${siteName.replace(/[^a-z0-9]/gi, '_')}-survey-v3-7-${Date.now()}.json`;
a.click();
URL.revokeObjectURL(url);
}

function loadFromJSON(event) {
const file = event.target.files[0];
if (!file) return;

const reader = new FileReader();
reader.onload = (e) => {
try {
const data = JSON.parse(e.target.result);
linePoints = data.linePoints || [];

markers = (data.markers || []).map(m => ({
...m,
spanLength: m.spanLength ? parseFloat(m.spanLength) : 0,
type: m.type || 'pole',
poleType: m.poleType || (m.type === 'pole' || m.type === 'dtr' ? 'HT' : null),
isLineBreak: m.isLineBreak || false, 
lat: m.lat,
lng: m.lng
})); 
siteName = data.siteName || 'New Survey Site'; 
document.getElementById('siteNameInput').value = siteName; 

updateTotalDistance(); 
updateUI();
drawMap();
drawLeafletMap(); 
updateMarkersList();
alert(`Survey data loaded successfully! (Version: ${data.version || 'Unknown'})`);
} catch (error) {
console.error("Load JSON Error:", error);
alert('Error loading file. Please check the file format.');
}
};
reader.readAsText(file);
event.target.value = '';
}

function exportToPNG() {
const canvas = document.getElementById('mapCanvas');
const pdfCanvas = document.createElement('canvas');
const pdfCtx = pdfCanvas.getContext('2d');
pdfCanvas.width = 800;
pdfCanvas.height = 1000;

pdfCtx.fillStyle = '#ffffff';
pdfCtx.fillRect(0, 0, pdfCanvas.width, pdfCanvas.height);

pdfCtx.fillStyle = '#000000';
pdfCtx.font = 'bold 24px Arial';
pdfCtx.fillText('Electrical Line Survey Report (V3.7)', 50, 40);

pdfCtx.font = '14px Arial';
pdfCtx.fillText(`Site Name: ${siteName}`, 50, 70); 
pdfCtx.fillText(`Date: ${new Date().toLocaleDateString()}`, 50, 90);
pdfCtx.fillText(`Total Distance: ${totalDistance.toFixed(2)} meters (Straight Line)`, 50, 110);
pdfCtx.fillText(`Total Points: ${linePoints.length}`, 50, 130);
pdfCtx.fillText(`Markers: ${markers.length}`, 50, 150);

pdfCtx.drawImage(canvas, 50, 170, 700, 500); 

pdfCtx.font = 'bold 16px Arial';
pdfCtx.fillText('Symbol Description', 550, 680);

let legendY = 710;
Object.values(markerTypes).forEach(type => {
pdfCtx.font = '24px Arial';
pdfCtx.fillText(type.icon, 560, legendY);
pdfCtx.font = '14px Arial';
pdfCtx.fillText(type.label, 600, legendY - 5);
legendY += 30;
});

pdfCtx.font = 'bold 16px Arial';
pdfCtx.fillText('Span Color Legend (Line Type to End Marker):', 50, 710);
let spanLegendY = 740;
Object.values(poleTypes).forEach(ptype => {
pdfCtx.fillStyle = ptype.color;
pdfCtx.fillRect(50, spanLegendY - 10, 20, 10);
pdfCtx.fillStyle = '#000000';
pdfCtx.font = '14px Arial';
pdfCtx.fillText(ptype.label, 80, spanLegendY);
spanLegendY += 20;
});

pdfCtx.font = 'bold 14px Arial';
pdfCtx.fillText('GPS Coordinates & Span:', 50, spanLegendY + 20);

let coordY = spanLegendY + 50;
pdfCtx.font = '12px Arial';
markers.forEach((marker, idx) => {
if (coordY > 950) return;
const type = markerTypes[marker.type];
const pole = marker.poleType ? ` (${marker.poleType})` : '';
let span = '';
if (marker.isLineBreak && marker.startFromMarkerId) {
const startMarkerIdx = markers.findIndex(m => m.id === marker.startFromMarkerId);
span = ` (Jump Span: ${marker.spanLength.toFixed(0)}m from #${startMarkerIdx + 1})`;
} else if (marker.spanLength && !marker.isLineBreak) {
span = ` (Span: ${marker.spanLength.toFixed(0)}m)`;
} else if (marker.isLineBreak) {
span = ' (LINE BREAK - No Connection)';
}
pdfCtx.fillText(
`${idx + 1}. ${type.label}${pole}: ${marker.lat.toFixed(6)}, ${marker.lng.toFixed(6)}${span}`,
50,
coordY
);
coordY += 20;
});

pdfCtx.fillStyle = '#6b7280';
pdfCtx.font = '10px Arial';
pdfCtx.textAlign = 'center';

// START: ADDED AND MODIFIED COPYRIGHT LINES IN PNG EXPORT
pdfCtx.fillText(
'¬© 2025‚Äì26 ErAjay Kumar . All rights reserved.',
pdfCanvas.width / 2,
980 
);
pdfCtx.fillText(
'Developed for Professional Field Use | Survey App Version 3.7 | For technical support, contact +91-70187-56182/ErAjay.HPSEB@gmail.com',
pdfCanvas.width / 2,
990 
);
// END: ADDED AND MODIFIED COPYRIGHT LINES IN PNG EXPORT

pdfCanvas.toBlob((blob) => {
const url = URL.createObjectURL(blob);
const a = document.createElement('a');
a.href = url;
a.download = `${siteName.replace(/[^a-z0-9]/gi, '_')}-report-v3-7-${Date.now()}.png`;
a.click();
URL.revokeObjectURL(url);
alert('Report exported successfully as PNG image!');
});
}

function exportToCSV() {
  if (markers.length === 0) {
    alert('No markers to export.');
    return;
  }

  // Updated header: SiteName, SpanDescription first, then existing columns
  let csvContent = "Site Name,Span Description,Marker #,Type,Pole Type,Latitude,Longitude,Span Length (m),Connected From Marker,Progressive Total Length (m),Line Break\n";

  let cumulativeDistance = 0;

  markers.forEach((marker, idx) => {
    const markerNumber = idx + 1;
    const typeLabel = markerTypes[marker.type].label;
    const poleTypeLabel = marker.poleType ? poleTypes[marker.poleType].label : 'N/A';
    const span = marker.spanLength || 0; 
    const lat = marker.lat.toFixed(6);
    const lng = marker.lng.toFixed(6);
    const isLineBreak = marker.isLineBreak ? 'YES' : 'NO';

    let connectedFrom = '';
    if (marker.isLineBreak && marker.startFromMarkerId) {
      const startMarkerIdx = markers.findIndex(m => m.id === marker.startFromMarkerId);
      connectedFrom = `Marker #${startMarkerIdx + 1} (Jump)`;
    } else if (!marker.isLineBreak && idx > 0) {
      connectedFrom = `Marker #${idx}`;
    } else {
      connectedFrom = 'N/A';
    }

    if (span > 0) {
      cumulativeDistance += span;
    }

    const spanText = (idx === 0) ? '0.00' : span.toFixed(2);

    // Build Span Description
    let spanDescription = "N/A";
    if (marker.isLineBreak && marker.startFromMarkerId && marker.spanLength > 0) {
      const startMarkerIdx = markers.findIndex(m => m.id === marker.startFromMarkerId);
      spanDescription = `Marker ${startMarkerIdx + 1} - Marker ${idx + 1}`;
    } else if (idx > 0 && marker.spanLength && !marker.isLineBreak) {
      spanDescription = `Marker ${idx} - Marker ${idx + 1}`;
    }

    const row = [
      siteName,                // new first column
      spanDescription,         // new second column
      markerNumber,
      typeLabel,
      poleTypeLabel,
      lat,
      lng,
      spanText,
      connectedFrom,
      cumulativeDistance.toFixed(2),
      isLineBreak
    ].map(item => `"${item}"`).join(',');

    csvContent += row + "\n";
  });

  const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = `${siteName.replace(/[^a-z0-9]/gi, '_')}-data-v3-7-${Date.now()}.csv`;
  a.click();
  URL.revokeObjectURL(url);
  alert('Data exported successfully as CSV/Excel!');
}



drawMap();
initLeafletMap();
selectMarkerType(selectedMarkerType);
</script>

</body>
</html>
